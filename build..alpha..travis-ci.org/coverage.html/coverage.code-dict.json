{"/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/test.js":"/* istanbul instrument in package npmtest_eslint_plugin_angular */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/lib.npmtest_eslint_plugin_angular.js":"/* istanbul instrument in package npmtest_eslint_plugin_angular */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_eslint_plugin_angular = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_eslint_plugin_angular = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-eslint-plugin-angular && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_eslint_plugin_angular */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_eslint_plugin_angular\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_eslint_plugin_angular.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_eslint_plugin_angular.rollup.js'] =\n            local.assetsDict['/assets.npmtest_eslint_plugin_angular.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_eslint_plugin_angular.__dirname +\n                    '/lib.npmtest_eslint_plugin_angular.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/index.js":"'use strict';\n\n/* eslint-disable global-require */\n\nvar fs = require('fs');\nvar path = require('path');\n\nvar rules = {};\nvar ruleDir = path.join(__dirname, 'rules');\n\nfs.readdirSync(ruleDir).forEach(function(name) {\n    var match = name.match(/(.+)\\.js$/);\n    if (match) {\n        rules[match[1]] = require(path.join(ruleDir, name));\n    }\n});\n\nmodule.exports = {\n    rules: rules,\n    environments: require('./environments'),\n    configs: {\n        johnpapa: {\n            plugins: [\n                'angular'\n            ],\n            rules: {\n                'angular/component-name': 2,\n                'angular/constant-name': 2,\n                'angular/controller-as-route': 2,\n                'angular/controller-as-vm': 2,\n                'angular/controller-as': 2,\n                'angular/controller-name': 2,\n                'angular/directive-name': 2,\n                'angular/directive-restrict': 2,\n                'angular/document-service': 2,\n                'angular/factory-name': 2,\n                'angular/file-name': 2,\n                'angular/filter-name': 2,\n                'angular/function-type': 2,\n                'angular/interval-service': 2,\n                'angular/module-getter': 2,\n                'angular/module-name': 2,\n                'angular/module-setter': 2,\n                'angular/no-run-logic': 2,\n                'angular/no-service-method': 2,\n                'angular/provider-name': 2,\n                'angular/service-name': 2,\n                'angular/timeout-service': 2,\n                'angular/value-name': 2,\n                'angular/window-service': 2\n            }\n        },\n        bestpractices: {\n            plugins: [\n                'angular'\n            ],\n            rules: {\n                'angular/component-name': 2,\n                'angular/constant-name': 2,\n                'angular/controller-as-route': 2,\n                'angular/controller-as-vm': 2,\n                'angular/controller-as': 2,\n                'angular/deferred': 2,\n                'angular/di-unused': 2,\n                'angular/directive-restrict': 2,\n                'angular/empty-controller': 2,\n                'angular/no-controller': 2,\n                'angular/no-inline-template': 2,\n                'angular/no-run-logic': 2,\n                'angular/no-service-method': 2,\n                'angular/no-services': 2,\n                'angular/on-watch': 2,\n                'angular/prefer-component': 2\n            }\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/angularelement.js":"/**\n * use `angular.element` instead of `$` or `jQuery`\n *\n * The angular.element method should be used instead of the $ or jQuery object (if you are using jQuery of course).\n * If the jQuery library is imported, angular.element will be a wrapper around the jQuery object.\n *\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        return {\n            CallExpression: function(node) {\n                if (node.callee.name === '$' || node.callee.name === 'jQuery') {\n                    context.report(node, 'You should use angular.element instead of the jQuery $ object', {});\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/avoid-scope-typos.js":"/**\n * Avoid mistakes when naming methods defined on the scope object\n *\n * For example, you want to use $scope.$watch instead of $scope.watch\n *\n * @version 2.3.0\n * @category possibleError\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nconst bad = ['new', 'watch', 'watchGroup', 'watchCollection',\n    'digest', 'destroy', 'eval', 'evalAsync', 'apply',\n    'applyAsync', 'on', 'emit', 'broadcast'];\n\nmodule.exports = {\n    meta: {\n        schema: [ ]\n    },\n    create: function(context) {\n        function check(node, name) {\n            if (bad.indexOf(name) >= 0) {\n                context.report(node, `The ${name} method should be replaced by $${name}, or you should rename it in order to avoid confusions`, {});\n            }\n        }\n        return {\n\n            Identifier: function(node) {\n                check(node, node.name);\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/component-limit.js":"/**\n * limit the number of angular components per file\n *\n * The number of AngularJS components in one file should be limited.\n * The default limit is one.\n *\n * ### Options\n *\n * - The acceptable number of components. (Default: 1)\n *\n * @styleguideReference {johnpapa} `y001` Define 1 component per file\n * @version 0.11.0\n * @category bestPractice\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar angularRule = require('./utils/angular-rule');\n\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'integer'\n        }]\n    },\n    create: angularRule(function(context) {\n        var limit = context.options[0] || 1;\n        var count = 0;\n        var msg = 'There may be at most {{limit}} AngularJS {{component}} per file, but found {{number}}';\n\n        function checkLimit(callee) {\n            count++;\n            if (count > limit) {\n                context.report(callee, msg, {\n                    limit: limit,\n                    component: limit === 1 ? 'component' : 'components',\n                    number: count\n                });\n            }\n        }\n\n        return {\n            'angular?animation': checkLimit,\n            'angular?config': checkLimit,\n            'angular?controller': checkLimit,\n            'angular?directive': checkLimit,\n            'angular?factory': checkLimit,\n            'angular?filter': checkLimit,\n            'angular?provider': checkLimit,\n            'angular?run': checkLimit,\n            'angular?service': checkLimit,\n            'angular?component': checkLimit\n        };\n    })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/utils/angular-rule.js":"'use strict';\n\nmodule.exports = angularRule;\n\n\n/**\n * Method names from an AngularJS module which can be chained.\n */\nvar angularChainableNames = [\n    'animation',\n    'component',\n    'config',\n    'constant',\n    'controller',\n    'directive',\n    'factory',\n    'filter',\n    'provider',\n    'run',\n    'service',\n    'value'\n];\n\n\n/**\n * An angularRule defines a simplified interface for AngularJS component based rules.\n *\n * A full rule definition containing rules for all supported rules looks like this:\n * ```js\n * module.exports = angularRule(function(context) {\n *   return {\n *     'angular?animation': function(configCallee, configFn) {},\n *     'angular?component': function(componentCallee, componentObj) {},\n *     'angular?config': function(configCallee, configFn) {},\n *     'angular?controller': function(controllerCallee, controllerFn) {},\n *     'angular?directive': function(directiveCallee, directiveFn) {},\n *     'angular?factory': function(factoryCallee, factoryFn) {},\n *     'angular?filter': function(filterCallee, filterFn) {},\n *     'angular?inject': function(injectCallee, injectFn) {},  // inject() calls from angular-mocks\n *     'angular?run': function(runCallee, runFn) {},\n *     'angular?service': function(serviceCallee, serviceFn) {},\n *     'angular?provider': function(providerCallee, providerFn, provider$getFn) {}\n *   };\n * })\n * ```\n */\nfunction angularRule(ruleDefinition) {\n    var angularComponents;\n    var angularModuleCalls;\n    var angularModuleIdentifiers;\n    var angularChainables;\n    var injectCalls;\n\n    return wrapper;\n\n    function reset() {\n        angularComponents = [];\n        angularModuleCalls = [];\n        angularModuleIdentifiers = [];\n        angularChainables = [];\n        injectCalls = [];\n    }\n\n    /**\n     * A wrapper around the rule definition.\n     */\n    function wrapper(context) {\n        reset();\n        var ruleObject = ruleDefinition(context);\n        injectCall(ruleObject, context, 'CallExpression:exit', checkCallee);\n        injectCall(ruleObject, context, 'Program:exit', callAngularRules);\n        return ruleObject;\n    }\n\n    /**\n     * Makes sure an extra function gets called after custom defined rule has run.\n     */\n    function injectCall(ruleObject, context, propName, toCallAlso) {\n        var original = ruleObject[propName];\n        ruleObject[propName] = callBoth;\n\n        function callBoth(node) {\n            if (original) {\n                original.call(ruleObject, node);\n            }\n            toCallAlso(ruleObject, context, node);\n        }\n    }\n\n    /**\n     * Collect expressions from an entire Angular module call chain expression statement and inject calls.\n     *\n     * This collects the following nodes:\n     * ```js\n     * angular.module()\n     *         ^^^^^^\n     * .animation('', function() {})\n     *  ^^^^^^^^^     ^^^^^^^^^^\n     * .component('', {})\n     *  ^^^^^^^^^\n     * .config(function() {})\n     *  ^^^^^^ ^^^^^^^^^^\n     * .constant()\n     *  ^^^^^^^^\n     * .controller('', function() {})\n     *  ^^^^^^^^^^     ^^^^^^^^^^\n     * .directive('', function() {})\n     *  ^^^^^^^^^     ^^^^^^^^^^\n     * .factory('', function() {})\n     *  ^^^^^^^     ^^^^^^^^^^\n     * .filter('', function() {})\n     *  ^^^^^^     ^^^^^^^^^^\n     * .provider('', function() {})\n     *  ^^^^^^^^     ^^^^^^^^^^\n     * .run('', function() {})\n     *  ^^^     ^^^^^^^^^^\n     * .service('', function() {})\n     *  ^^^^^^^     ^^^^^^^^^^\n     * .value();\n     *  ^^^^^\n     *\n     * inject(function() {})\n     * ^^^^^^ ^^^^^^^^^^\n     * ```\n     */\n    function checkCallee(ruleObject, context, callExpressionNode) {\n        var callee = callExpressionNode.callee;\n        if (callee.type === 'Identifier') {\n            if (callee.name === 'inject') {\n                // inject()\n                // ^^^^^^\n                injectCalls.push({\n                    callExpression: callExpressionNode,\n                    fn: findFunctionByNode(callExpressionNode, context.getScope())\n                });\n            }\n            return;\n        }\n        if (callee.type === 'MemberExpression') {\n            if (callee.object.name === 'angular' && callee.property.name === 'module') {\n                // angular.module()\n                //         ^^^^^^\n                angularModuleCalls.push(callExpressionNode);\n            } else if (angularChainableNames.indexOf(callee.property.name !== -1) && (angularModuleCalls.indexOf(callee.object) !== -1 || angularChainables.indexOf(callee.object) !== -1)) {\n                // angular.module().factory().controller()\n                //                  ^^^^^^^   ^^^^^^^^^^\n                angularChainables.push(callExpressionNode);\n                angularComponents.push({\n                    callExpression: callExpressionNode,\n                    fn: findFunctionByNode(callExpressionNode, context.getScope())\n                });\n            } else if (callee.object.type === 'Identifier') {\n                // var app = angular.module(); app.factory()\n                //                                 ^^^^^^^\n                var scope = context.getScope();\n                var isAngularModule = scope.variables.some(function(variable) {\n                    if (callee.object.name !== variable.name) {\n                        return false;\n                    }\n                    return variable.identifiers.some(function(id) {\n                        return angularModuleIdentifiers.indexOf(id) !== -1;\n                    });\n                });\n                if (isAngularModule) {\n                    angularChainables.push(callExpressionNode);\n                    angularComponents.push({\n                        callExpression: callExpressionNode,\n                        fn: findFunctionByNode(callExpressionNode, context.getScope())\n                    });\n                } else {\n                    return;\n                }\n            } else {\n                return;\n            }\n            if (callExpressionNode.parent.type === 'VariableDeclarator') {\n                // var app = angular.module()\n                //     ^^^\n                angularModuleIdentifiers.push(callExpressionNode.parent.id);\n            }\n        }\n    }\n\n    /**\n     * Find the function expression or function declaration by an Angular component callee.\n     */\n    function findFunctionByNode(callExpressionNode, scope) {\n        var node;\n        if (callExpressionNode.callee.type === 'Identifier') {\n            node = callExpressionNode.arguments[0];\n        } else if (callExpressionNode.callee.property.name === 'run' || callExpressionNode.callee.property.name === 'config') {\n            node = callExpressionNode.arguments[0];\n        } else {\n            node = callExpressionNode.arguments[1];\n        }\n        if (!node) {\n            return;\n        }\n        if (node.type === 'ArrayExpression') {\n            node = node.elements[node.elements.length - 1] || {};\n        }\n        if (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression' || node.type === 'FunctionDeclaration') {\n            return node;\n        }\n        if (node.type !== 'Identifier') {\n            return;\n        }\n\n        var func;\n        scope.variables.some(function(variable) {\n            if (variable.name === node.name) {\n                variable.defs.forEach(function(def) {\n                    if (def.node.type === 'FunctionDeclaration') {\n                        func = def.node;\n                        return true;\n                    }\n                });\n                return true;\n            }\n        });\n        return func;\n    }\n\n    /**\n     * Call the Angular specific rules defined by the rule definition.\n     */\n    function callAngularRules(ruleObject, context) {\n        angularComponents.forEach(function(component) {\n            var name = component.callExpression.callee.property.name;\n            var fn = ruleObject['angular?' + name];\n            if (!fn) {\n                return;\n            }\n            fn.apply(ruleObject, assembleArguments(component, context));\n        });\n        var injectRule = ruleObject['angular?inject'];\n        if (injectRule) {\n            injectCalls.forEach(function(node) {\n                injectRule.call(ruleObject, node.CallExpression, node.fn);\n            });\n        }\n    }\n\n    /**\n     * Assemble the arguments for an Angular callee check.\n     */\n    function assembleArguments(node) {\n        switch (node.callExpression.callee.property.name) {\n            case 'animation':\n            case 'component':\n            case 'config':\n            case 'controller':\n            case 'directive':\n            case 'factory':\n            case 'filter':\n            case 'run':\n            case 'service':\n                return [node.callExpression.callee, node.fn];\n            case 'provider':\n                return assembleProviderArguments(node);\n        }\n    }\n\n    /**\n     * Assemble arguments for a provider rule.\n     *\n     * On top of a regular Angular component rule, the provider rule gets called with the $get function as its 3rd argument.\n     */\n    function assembleProviderArguments(node) {\n        return [node.callExpression, node.fn, findProviderGet(node.fn)];\n    }\n\n    /**\n     * Find the $get function of a provider based on the provider function body.\n     */\n    function findProviderGet(providerFn) {\n        if (!providerFn) {\n            return;\n        }\n        var getFn;\n        providerFn.body.body.some(function(statement) {\n            var expression = statement.expression;\n            if (!expression || expression.type !== 'AssignmentExpression') {\n                return;\n            }\n            if (expression.left.type === 'MemberExpression' && expression.left.property.name === '$get') {\n                getFn = expression.right;\n                return true;\n            }\n        });\n        if (!getFn) {\n            return;\n        }\n        if (getFn.type === 'ArrayExpression') {\n            return getFn.elements[getFn.elements.length - 1];\n        }\n        return getFn;\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/component-name.js":"/**\n * require and specify a prefix for all component names\n *\n * All your components should have a name starting with the parameter you can define in your config object.\n * The second parameter can be a Regexp wrapped in quotes.\n * You can not prefix your components by \"ng\" (reserved keyword for AngularJS components) (\"component-name\":  [2, \"ng\"])\n *\n * @version 0.1.0\n * @category naming\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: ['string', 'object']\n        }]\n    },\n    create: function(context) {\n        if (context.settings.angular === 2) {\n            return {};\n        }\n\n        return {\n\n            CallExpression: function(node) {\n                var prefix = context.options[0];\n                var convertedPrefix; // convert string from JSON .eslintrc to regex\n\n                if (prefix === undefined) {\n                    return;\n                }\n\n                convertedPrefix = utils.convertPrefixToRegex(prefix);\n\n                if (utils.isAngularComponentDeclaration(node)) {\n                    var name = node.arguments[0].value;\n\n                    if (name !== undefined && name.indexOf('ng') === 0) {\n                        context.report(node, 'The {{component}} component should not start with \"ng\". This is reserved for AngularJS components', {\n                            component: name\n                        });\n                    } else if (name !== undefined && !convertedPrefix.test(name)) {\n                        if (typeof prefix === 'string' && !utils.isStringRegexp(prefix)) {\n                            context.report(node, 'The {{component}} component should be prefixed by {{prefix}}', {\n                                component: name,\n                                prefix: prefix\n                            });\n                        } else {\n                            context.report(node, 'The {{component}} component should follow this pattern: {{prefix}}', {\n                                component: name,\n                                prefix: prefix.toString()\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/utils/utils.js":"'use strict';\nvar falseConfigValues = require('./false-values').config;\nvar falseRunValues = require('./false-values').run;\n\nvar scopeProperties = [\n    '$id',\n    '$parent',\n    '$root',\n    '$destroy',\n    '$broadcast',\n    '$emit',\n    '$on',\n    '$applyAsync',\n    '$apply',\n    '$evalAsync',\n    '$eval',\n    '$digest',\n    '$watchCollection',\n    '$watchGroup',\n    '$watch',\n    '$new'\n];\n\n\nmodule.exports = {\n    // Properties\n    scopeProperties: scopeProperties,\n\n    // Functions\n    convertPrefixToRegex: convertPrefixToRegex,\n    convertStringToRegex: convertStringToRegex,\n    isTypeOfStatement: isTypeOfStatement,\n    isToStringStatement: isToStringStatement,\n    isArrayType: isArrayType,\n    isFunctionType: isFunctionType,\n    isNamedInlineFunction: isNamedInlineFunction,\n    isIdentifierType: isIdentifierType,\n    isMemberExpression: isMemberExpression,\n    isLiteralType: isLiteralType,\n    isCallExpression: isCallExpression,\n    isEmptyFunction: isEmptyFunction,\n    isStringRegexp: isStringRegexp,\n    isAngularComponent: isAngularComponent,\n    isAngularComponentDeclaration: isAngularComponentDeclaration,\n    isAngularControllerDeclaration: isAngularControllerDeclaration,\n    isAngularFilterDeclaration: isAngularFilterDeclaration,\n    isAngularDirectiveDeclaration: isAngularDirectiveDeclaration,\n    isAngularServiceDeclarationDeprecated: isAngularServiceDeclarationDeprecated,\n    isAngularServiceDeclaration: isAngularServiceDeclaration,\n    isAngularProviderDeclaration: isAngularProviderDeclaration,\n    isAngularFactoryDeclaration: isAngularFactoryDeclaration,\n    isAngularConstantDeclaration: isAngularConstantDeclaration,\n    isAngularValueDeclaration: isAngularValueDeclaration,\n    isAngularModuleDeclaration: isAngularModuleDeclaration,\n    isAngularModuleGetter: isAngularModuleGetter,\n    isAngularRunSection: isAngularRunSection,\n    isAngularConfigSection: isAngularConfigSection,\n    isRouteDefinition: isRouteDefinition,\n    isUIRouterStateDefinition: isUIRouterStateDefinition,\n    findIdentiferInScope: findIdentiferInScope,\n    getControllerDefinition: getControllerDefinition,\n    isAngularServiceImport: isAngularServiceImport,\n    getToStringTagType: getToStringTagType\n};\n\n\n/**\n * Recursively grab the callee until an Identifier is found.\n *\n * @todo Needs better documentation.\n */\nfunction getCallingIdentifier(calleeObject) {\n    if (calleeObject.type && calleeObject.type === 'Identifier') {\n        return calleeObject;\n    }\n    if (calleeObject.callee && calleeObject.callee.object) {\n        return getCallingIdentifier(calleeObject.callee.object);\n    }\n    return null;\n}\n\n/**\n * Convert a prefix string to a RegExp.\n *\n * `'/app/'` → `/app.*\\/`\n *\n * @param {string} prefix\n * @returns {RegExp}\n */\nfunction convertPrefixToRegex(prefix) {\n    if (typeof prefix !== 'string') {\n        return prefix;\n    }\n\n    if (prefix[0] === '/' && prefix[prefix.length - 1] === '/') {\n        prefix = prefix.substring(1, prefix.length - 1);\n    }\n\n    return new RegExp(prefix + '.*');\n}\n\n/**\n * Convert a string to a RegExp.\n *\n * `'app'` → `/app/`\n * `'/app/'` → `/app/`\n *\n * @param {string} prefix\n * @returns {RegExp}\n */\nfunction convertStringToRegex(string) {\n    if (string[0] === '/' && string[string.length - 1] === '/') {\n        string = string.substring(1, string.length - 2);\n    }\n    return new RegExp(string);\n}\n\n/**\n * @todo Missing documentation\n */\nfunction isTypeOfStatement(node) {\n    return node.type === 'Identifier' || (node.type === 'UnaryExpression' && node.operator === 'typeof');\n}\n\n/**\n * @todo Missing documentation\n *\n * @param {Object} node The node to check.\n * @returns {boolean} Whether or not the node is a `toString` statement.\n */\nfunction isToStringStatement(node) {\n    return node.type === 'CallExpression' &&\n        node.callee.type === 'MemberExpression' &&\n        node.callee.object.type === 'MemberExpression' &&\n        node.callee.object.property.name === 'toString' &&\n        node.callee.property.name === 'call' &&\n        node.callee.object.object.type === 'MemberExpression' &&\n        node.callee.object.object.object.name === 'Object' &&\n        node.callee.object.object.property.name === 'prototype';\n}\n\n/**\n * Check whether or not a node is an ArrayExpression.\n *\n * @param {Object} node The node to check.\n * @returns {boolean} Whether or not the node is an ArrayExpression.\n */\nfunction isArrayType(node) {\n    return node !== undefined && node.type === 'ArrayExpression';\n}\n\n/**\n * Check whether or not a node is an FunctionExpression.\n *\n * @param {Object} node The node to check.\n * @returns {boolean} Whether or not the node is an FunctionExpression.\n */\nfunction isFunctionType(node) {\n    return node !== undefined && (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression');\n}\n\n/**\n * Check whether or not a node is an named FunctionExpression.\n *\n * @param {Object} node The node to check.\n * @returns {boolean} Whether or not the node is an named FunctionExpression.\n */\nfunction isNamedInlineFunction(node) {\n    return this.isFunctionType(node) && node.id && node.id.name && node.id.name.length > 0;\n}\n\n/**\n * Check whether or not a node is an Identifier.\n *\n * @param {Object} node The node to check.\n * @returns {boolean} Whether or not the node is an Identifier.\n */\nfunction isIdentifierType(node) {\n    return node !== undefined && node.type === 'Identifier';\n}\n\n/**\n * Check whether or not a node is an MemberExpression.\n *\n * @param {Object} node The node to check.\n * @returns {boolean} Whether or not the node is an MemberExpression.\n */\nfunction isMemberExpression(node) {\n    return node !== undefined && node.type === 'MemberExpression';\n}\n\n/**\n * Check whether or not a node is an Literal.\n *\n * @param {Object} node The node to check.\n * @returns {boolean} Whether or not the node is an Literal.\n */\nfunction isLiteralType(node) {\n    return node !== undefined && node.type === 'Literal';\n}\n\n/**\n * Check whether or not a node is a CallExpression.\n *\n * @param {Object} node The node to check.\n * @returns {boolean} Whether or not the node is a CallExpression.\n */\nfunction isCallExpression(node) {\n    return node !== undefined && node.type === 'CallExpression';\n}\n\n/**\n * Check whether or not a node is an isEmptyFunction.\n *\n * @param {Object} node The node to check.\n * @returns {boolean} Whether or not the node is an isEmptyFunction.\n */\nfunction isEmptyFunction(fn) {\n    return fn.body.body.length === 0;\n}\n\n/**\n * Check whether or not a string resembles a regular expression.\n *\n * A string is considered a regular expression if it starts and ends with `/`.\n *\n * @param {string} The string to check.\n * @returns {boolean} Whether or not a string resembles a regular expression.\n */\nfunction isStringRegexp(string) {\n    return string[0] === '/' && string[string.length - 1] === '/';\n}\n\n/**\n * Check if a CallExpression node somewhat resembles an Angular component.\n *\n * The following are considered Angular components\n * ```js\n * app.factory('kittenService', function() {})\n *     ^^^^^^^\n * app.factory('kittenService', kittenService)\n *     ^^^^^^^\n * app.factory('kittenService', [])\n *     ^^^^^^^\n * app.factory('kittenService', require(\"\"))\n *     ^^^^^^^\n * asyncFn('value', callback)\n * ^^^^^^^\n * ```\n *\n * @todo FIXME\n *\n * @param {Object} node The CallExpression node to check.\n * @returns {boolean} Whether or not the node somewhat resembles an Angular component.\n */\nfunction isAngularComponent(node) {\n    return node.arguments !== undefined &&\n        node.arguments.length === 2 &&\n        (isLiteralType(node.arguments[0]) || isIdentifierType(node.arguments[0])) &&\n        (isIdentifierType(node.arguments[1]) ||\n         isFunctionType(node.arguments[1]) ||\n         isArrayType(node.arguments[1]) ||\n         isCallExpression(node.arguments[1]));\n}\n\n/**\n * Check whether a CallExpression node defines an Angular component.\n *\n * @param {Object} node The CallExpression node to check.\n * @returns {boolean} Whether or not the node defines an Angular component.\n */\nfunction isAngularComponentDeclaration(node) {\n    return node.arguments !== undefined &&\n        node.arguments.length === 2 &&\n        isLiteralType(node.arguments[0]) &&\n        node.arguments[1].type === 'ObjectExpression' &&\n        isMemberExpression(node.callee) &&\n        node.callee.property.name === 'component';\n}\n\n/**\n * Check whether a CallExpression node defines an Angular controller.\n *\n * @param {Object} node The CallExpression node to check.\n * @returns {boolean} Whether or not the node defines an Angular controller.\n */\nfunction isAngularControllerDeclaration(node) {\n    return isAngularComponent(node) &&\n        isMemberExpression(node.callee) &&\n        node.callee.property.name === 'controller';\n}\n\n/**\n * Check whether a CallExpression node defines an Angular filter.\n *\n * @param {Object} node The CallExpression node to check.\n * @returns {boolean} Whether or not the node defines an Angular filter.\n */\nfunction isAngularFilterDeclaration(node) {\n    return isAngularComponent(node) &&\n        isMemberExpression(node.callee) &&\n        node.callee.property.name === 'filter';\n}\n\n/**\n * Check whether a CallExpression node defines an Angular directive.\n *\n * @param {Object} node The CallExpression node to check.\n * @returns {boolean} Whether or not the node defines an Angular directive.\n */\nfunction isAngularDirectiveDeclaration(node) {\n    return isAngularComponent(node) &&\n        isMemberExpression(node.callee) &&\n        node.callee.property.name === 'directive';\n}\n\n/**\n * Check whether a node defines an Angular service.\n *\n * The following are considered services\n * ```js\n * app.provider('kittenServiceProvider', function() {})\n *     ^^^^^^^^\n * app.factory('kittenService', function() {})\n *     ^^^^^^^\n * app.service('kittenService', function() {})\n *     ^^^^^^^\n * app.constant('KITTENS', function() {})\n *     ^^^^^^^^\n * app.value('KITTENS', function() {})\n *     ^^^^^\n * ```\n *\n * The following are not considered services\n * ```js\n * $provide.factory('kittenService', function() {})\n * app.constant('KITTENS', 'meow')\n * app.value('KITTENS', 'purr')\n * this.$get = function() {}\n * ```\n *\n * @todo FIXME\n *\n * @param {Object} node The CallExpression node to check.\n * @returns {boolean} Whether or not the node defines an Angular controller.\n */\nfunction isAngularServiceDeclarationDeprecated(node) {\n    return isAngularComponent(node) &&\n        isMemberExpression(node.callee) &&\n        node.callee.object.name !== '$provide' &&\n        (node.callee.property.name === 'provider' ||\n         node.callee.property.name === 'service' ||\n         node.callee.property.name === 'factory' ||\n         node.callee.property.name === 'constant' ||\n         node.callee.property.name === 'value');\n}\n\n/*\n * @param {Object}\n * @returns {boolean}\n */\nfunction isAngularServiceDeclaration(node) {\n    return isAngularComponent(node) &&\n        isMemberExpression(node.callee) &&\n        node.callee.object.name !== '$provide' &&\n        node.callee.property.name === 'service';\n}\n\n/*\n * @param {Object}\n * @returns {boolean}\n */\nfunction isAngularProviderDeclaration(node) {\n    return isAngularComponent(node) &&\n        isMemberExpression(node.callee) &&\n        node.callee.object.name !== '$provide' &&\n        node.callee.property.name === 'provider';\n}\n\n/*\n * @param {Object}\n * @returns {boolean}\n */\nfunction isAngularFactoryDeclaration(node) {\n    return isAngularComponent(node) &&\n        isMemberExpression(node.callee) &&\n        node.callee.object.name !== '$provide' &&\n        node.callee.property.name === 'factory';\n}\n\n/*\n * @param {Object}\n * @returns {boolean}\n */\nfunction isAngularConstantDeclaration(node) {\n    return isAngularComponent(node) &&\n        isMemberExpression(node.callee) &&\n        node.callee.object.name !== '$provide' &&\n        node.callee.property.name === 'constant';\n}\n\nfunction isAngularValueDeclaration(node) {\n    return isAngularComponent(node) &&\n        isMemberExpression(node.callee) &&\n        node.callee.object.name !== '$provide' &&\n        node.callee.property.name === 'value';\n}\n\n/**\n * Check whether a CallExpression node declares an Angular module.\n *\n * @param {Object} node The CallExpression node to check.\n * @returns {boolean} Whether or not the node declares an Angular module.\n */\nfunction isAngularModuleDeclaration(node) {\n    return isAngularComponent(node) &&\n        isMemberExpression(node.callee) &&\n        node.callee.property.name === 'module';\n}\n\n/**\n * Check whether a CallExpression node gets or declares an Angular module.\n *\n * @param {Object} node The CallExpression node to check.\n * @returns {boolean} Whether or not the node gets or declares an Angular module.\n */\nfunction isAngularModuleGetter(node) {\n    return node.arguments !== undefined &&\n        node.arguments.length > 0 &&\n        (isLiteralType(node.arguments[0]) || isIdentifierType(node.arguments[0])) &&\n        node.callee.type === 'MemberExpression' &&\n        node.callee.property.name === 'module';\n}\n\n/**\n * Check whether a CallExpression node defines an Angular run function.\n *\n * The following are considered run functions\n * ```js\n * app.run()\n *     ^^^\n * app.run(function() {})\n *     ^^^\n * ```\n *\n * The following are not considered run functions\n * ```js\n * angular.module('myApp').run(function() {})\n * angular.module('myApp', []).run(function() {})\n * mocha.run()\n * ```\n *\n * @todo FIXME\n *\n * @param {Object} node The CallExpression node to check.\n * @returns {boolean} Whether or not the node defines an Angular run function.\n */\nfunction isAngularRunSection(node) {\n    return isMemberExpression(node.callee) &&\n        node.callee.property.type === 'Identifier' &&\n        node.callee.property.name === 'run' &&\n        !falseRunValues.find(pattern => new RegExp(pattern).test(node.callee.object.name));\n}\n\n/**\n * Check whether a CallExpression node defines an Angular config function.\n *\n * The following are considered config functions\n * ```js\n * app.config()\n *     ^^^^^^\n * app.config(function() {})\n *     ^^^^^^\n * ```\n *\n * The following are not considered run functions\n * ```js\n * angular.module('myApp').config(function() {})\n * angular.module('myApp', []).config(function() {})\n * ```\n *\n * @todo FIXME\n *\n * @param {Object} node The CallExpression node to check.\n * @returns {boolean} Whether or not the node defines an Angular config function.\n */\nfunction isAngularConfigSection(node) {\n    return isMemberExpression(node.callee) &&\n     node.callee.property.type === 'Identifier' &&\n     node.callee.property.name === 'config' &&\n     !falseConfigValues.find(pattern => new RegExp(pattern).test(node.callee.object.name));\n}\n\n/**\n * Check whether a CallExpression node defines a route using $routeProvider.\n *\n * The following are considered routes:\n * ```js\n * $routeProvider.when()\n *                ^^^^\n * ```\n *\n * @param {Object} node The CallExpression node to check.\n * @returns {boolean} Whether or not the node defines a route.\n */\nfunction isRouteDefinition(node) {\n    // the route def function is .when(), so when we find that, go up through the chain and make sure\n    // $routeProvider is the calling object\n    if (node.callee.property && node.callee.property.name === 'when') {\n        var callObject = getCallingIdentifier(node.callee.object);\n        return callObject && callObject.name === '$routeProvider';\n    }\n    return false;\n}\n\n/**\n * Check whether a CallExpression node defines a state using $stateProvider.\n *\n * The following are considered states:\n * ```js\n * $stateProvider.state()\n *                ^^^^^\n * ```\n *\n * @param {Object} node The CallExpression node to check.\n * @returns {boolean} Whether or not the node defines a state.\n */\nfunction isUIRouterStateDefinition(node) {\n    // the state def function is .state(), so when we find that, go up through the chain and make sure\n    // $stateProvider is the calling object\n    if (node.callee.property && node.callee.property.name === 'state') {\n        var callObject = getCallingIdentifier(node.callee.object);\n        return callObject && callObject.name === '$stateProvider';\n    }\n    return false;\n}\n\n/**\n * Find an identifier node in the current scope.\n *\n * @param {Object} context The context to use to get the scope.\n * @param {Object} identifier The identifier node to look up.\n *\n * @returns {Object} The node declaring the identifier.\n */\nfunction findIdentiferInScope(context, identifier) {\n    var identifierNode = null;\n    context.getScope().variables.forEach(function(variable) {\n        if (variable.name === identifier.name) {\n            identifierNode = variable.defs[0].node;\n            if (identifierNode.type === 'VariableDeclarator') {\n                identifierNode = identifierNode.init;\n            }\n        }\n    });\n    return identifierNode;\n}\n\n/**\n * Find the function definition of a controller in the current context.\n *\n * @param {Object} context The context to use to find the controller declaration.\n * @param {Object} node The Angular controller call to look up the declaration for.\n *\n * @returns {Object} The identifier declaring the controller function.\n */\nfunction getControllerDefinition(context, node) {\n    var controllerArg = node.arguments[1];\n\n    // Three ways of creating a controller function: function expression,\n    // variable name that references a function, and an array with a function\n    // as the last item\n    if (isFunctionType(controllerArg)) {\n        return controllerArg;\n    }\n    if (isArrayType(controllerArg)) {\n        controllerArg = controllerArg.elements[controllerArg.elements.length - 1];\n\n        if (isIdentifierType(controllerArg)) {\n            return findIdentiferInScope(context, controllerArg);\n        }\n        return controllerArg;\n    }\n    if (isIdentifierType(controllerArg)) {\n        return findIdentiferInScope(context, controllerArg);\n    }\n}\n\n/**\n * Check if the imported service support these two syntaxes : serviceName and _serviceName_\n *\n * @param {string} parameterName The label of the parameter.\n * @param {string} serviceName The name of the service.\n *\n * @returns {boolean} True if the service use on of these previous syntaxes.\n */\nfunction isAngularServiceImport(parameterName, serviceName) {\n    var r = new RegExp('^\\_?' + serviceName.replace(/[!@#$%^&*()+=\\-[\\]\\\\';,./{}|\":<>?~_]/g, '\\\\$&') + '\\_?$', 'i');\n    return r.test(parameterName);\n}\n\n/**\n * Return the value of the given param that retrieved by Object#toString()\n *\n * @param {*} obj\n * @return {string}\n */\nfunction getToStringTagType(obj) {\n    return Object.prototype.toString.apply(obj)\n        .match(/^\\[object\\s(.+)]$/)[1];\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/utils/false-values.js":"'use strict';\n\nmodule.exports = {\n    config: [/Provider$/, /$route/],\n    run: [/mocha/, /Service$/]\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/constant-name.js":"/**\n * require and specify a prefix for all constant names\n *\n * All your constants should have a name starting with the parameter you can define in your config object.\n * The second parameter can be a Regexp wrapped in quotes.\n * You can not prefix your constants by \"$\" (reserved keyword for AngularJS services) (\"constant-name\":  [2, \"ng\"])\n **\n * @styleguideReference {johnpapa} `y125` Naming - Factory and Service Names\n * @version 0.1.0\n * @category naming\n */\n'use strict';\n\n\nvar utils = require('./utils/utils');\n\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: ['string', 'object']\n        }, {\n            type: 'object'\n        }]\n    },\n    create: function(context) {\n        return {\n\n            CallExpression: function(node) {\n                var prefix = context.options[0];\n                var convertedPrefix; // convert string from JSON .eslintrc to regex\n                var isConstant;\n\n                if (prefix === undefined) {\n                    return;\n                }\n\n                convertedPrefix = utils.convertPrefixToRegex(prefix);\n                isConstant = utils.isAngularConstantDeclaration(node);\n\n                if (isConstant) {\n                    var name = node.arguments[0].value;\n\n                    if (name !== undefined && name.indexOf('$') === 0) {\n                        context.report(node, 'The {{constant}} constant should not start with \"$\". This is reserved for AngularJS services', {\n                            constant: name\n                        });\n                    } else if (name !== undefined && !convertedPrefix.test(name)) {\n                        if (typeof prefix === 'string' && !utils.isStringRegexp(prefix)) {\n                            context.report(node, 'The {{constant}} constant should be prefixed by {{prefix}}', {\n                                constant: name,\n                                prefix: prefix\n                            });\n                        } else {\n                            context.report(node, 'The {{constant}} constant should follow this pattern: {{prefix}}', {\n                                constant: name,\n                                prefix: prefix.toString()\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/controller-as-route.js":"/**\n * require the use of controllerAs in routes or states\n *\n * You should use Angular's controllerAs syntax when defining routes or states.\n *\n * @styleguideReference {johnpapa} `y031` controllerAs Controller Syntax\n * @version 0.1.0\n * @category bestPractice\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        return {\n            CallExpression: function(node) {\n                var routeObject = null;\n                var stateObject = null;\n                var hasControllerAs = false;\n                var controllerProp = null;\n                var stateName = null;\n\n                if (utils.isRouteDefinition(node)) {\n                    // second argument in $routeProvider.when('route', {...})\n                    routeObject = node.arguments[1];\n\n                    if (routeObject.properties) {\n                        routeObject.properties.forEach(function(prop) {\n                            if (prop.key.name === 'controller') {\n                                controllerProp = prop;\n\n                                if (new RegExp('\\\\sas\\\\s').test(prop.value.value)) {\n                                    hasControllerAs = true;\n                                }\n                            }\n\n                            if (prop.key.name === 'controllerAs') {\n                                if (hasControllerAs) {\n                                    context.report(node, 'The controllerAs syntax is defined twice for the route \"{{route}}\"', {\n                                        route: node.arguments[0].value\n                                    });\n                                }\n\n                                hasControllerAs = true;\n                            }\n                        });\n\n                        // if it's a route without a controller, we shouldn't warn about controllerAs\n                        if (controllerProp && !hasControllerAs) {\n                            context.report(node, 'Route \"{{route}}\" should use controllerAs syntax', {\n                                route: node.arguments[0].value\n                            });\n                        }\n                    }\n                } else if (utils.isUIRouterStateDefinition(node)) {\n                    // state can be defined like .state({...}) or .state('name', {...})\n                    var isObjectState = node.arguments.length === 1;\n                    stateObject = isObjectState ? node.arguments[0] : node.arguments[1];\n\n                    if (stateObject && stateObject.properties) {\n                        stateObject.properties.forEach(function(prop) {\n                            if (prop.key.name === 'controller') {\n                                controllerProp = prop;\n                            }\n                            if (prop.key.name === 'controllerAs') {\n                                hasControllerAs = true;\n                            }\n                            // grab the name from the object for when they aren't using .state('name',...)\n                            if (prop.key.name === 'name') {\n                                stateName = prop.value.value;\n                            }\n                        });\n\n                        if (!hasControllerAs && controllerProp) {\n                            // if the controller is a string, controllerAs can be set like 'controller as vm'\n                            if (controllerProp.value.type !== 'Literal' || controllerProp.value.value.indexOf(' as ') < 0) {\n                                context.report(node, 'State \"{{state}}\" should use controllerAs syntax', {\n                                    state: isObjectState ? stateName : node.arguments[0].value\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/controller-as-vm.js":"/**\n * require and specify a capture variable for `this` in controllers\n *\n * You should use a capture variable for 'this' when using the controllerAs syntax.\n * The second parameter specifies the capture variable you want to use in your application.\n * The third parameter can be a Regexp for identifying controller functions (when using something like Browserify)\n *\n * ### Options\n *\n * - The name that should be used for the view model.\n *\n * @styleguideReference {johnpapa} `y032` controllerAs with vm\n * @version 0.1.0\n * @category bestPractice\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'string'\n        }, {\n            type: 'string'\n        }]\n    },\n    create: function(context) {\n        var badStatements = [];\n        var badCaptureStatements = [];\n        var controllerFunctions = [];\n\n        var viewModelName = context.options[0] || 'vm';\n        // If your Angular code is written so that controller functions are in\n        // separate files from your .controller() calls, you can specify a regex for your controller function names\n        var controllerNameMatcher = context.options[1];\n        if (controllerNameMatcher && utils.isStringRegexp(controllerNameMatcher)) {\n            controllerNameMatcher = utils.convertStringToRegex(controllerNameMatcher);\n        }\n\n        // check node against known controller functions or pattern if specified\n        function isControllerFunction(node) {\n            return controllerFunctions.indexOf(node) >= 0 ||\n                (controllerNameMatcher && (node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration') &&\n                    node.id && controllerNameMatcher.test(node.id.name));\n        }\n\n        // for each of the bad uses, find any parent nodes that are controller functions\n        function reportBadUses() {\n            if (controllerFunctions.length > 0 || controllerNameMatcher) {\n                badCaptureStatements.forEach(function(item) {\n                    item.parents.filter(isControllerFunction).forEach(function() {\n                        context.report(item.stmt, 'You should assign \"this\" to a consistent variable across your project: {{capture}}',\n                            {\n                                capture: viewModelName\n                            }\n                        );\n                    });\n                });\n                badStatements.forEach(function(item) {\n                    item.parents.filter(isControllerFunction).forEach(function() {\n                        context.report(item.stmt, 'You should not use \"this\" directly. Instead, assign it to a variable called \"{{capture}}\"',\n                            {\n                                capture: viewModelName\n                            }\n                        );\n                    });\n                });\n            }\n        }\n\n        function isClassDeclaration(ancestors) {\n            return ancestors.findIndex(function(ancestor) {\n                return ancestor.type === 'ClassDeclaration';\n            }) > -1;\n        }\n\n        return {\n            // Looking for .controller() calls here and getting the associated controller function\n            'CallExpression:exit': function(node) {\n                if (utils.isAngularControllerDeclaration(node)) {\n                    controllerFunctions.push(utils.getControllerDefinition(context, node));\n                }\n            },\n            // statements are checked here for bad uses of $scope\n            ThisExpression: function(stmt) {\n                var parents = context.getAncestors();\n                if (!isClassDeclaration(parents)) {\n                    if (stmt.parent.type === 'VariableDeclarator') {\n                        if (!stmt.parent.id || stmt.parent.id.name !== viewModelName) {\n                            badCaptureStatements.push({parents: parents, stmt: stmt});\n                        }\n                    } else {\n                        badStatements.push({parents: parents, stmt: stmt});\n                    }\n                }\n            },\n            'Program:exit': function() {\n                reportBadUses();\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/controller-as.js":"/**\n * disallow assignments to `$scope` in controllers\n *\n * You should not set properties on $scope in controllers.\n * Use controllerAs syntax and add data to 'this'.\n * The second parameter can be a Regexp for identifying controller functions (when using something like Browserify)\n *\n * @styleguideReference {johnpapa} `y031` controllerAs Controller Syntax\n * @version 0.1.0\n * @category bestPractice\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: ['object', 'string']\n        }]\n    },\n    create: function(context) {\n        var badStatements = [];\n        var controllerFunctions = [];\n\n        // If your Angular code is written so that controller functions are in\n        // separate files from your .controller() calls, you can specify a regex for your controller function names\n        var controllerNameMatcher = context.options[0];\n        if (controllerNameMatcher && utils.isStringRegexp(controllerNameMatcher)) {\n            controllerNameMatcher = utils.convertStringToRegex(controllerNameMatcher);\n        }\n\n        // check node against known controller functions or pattern if specified\n        function isControllerFunction(node) {\n            return controllerFunctions.indexOf(node) >= 0 ||\n                (controllerNameMatcher && (node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration') &&\n                    node.id && controllerNameMatcher.test(node.id.name));\n        }\n\n        // for each of the bad uses, find any parent nodes that are controller functions\n        function reportBadUses() {\n            if (controllerFunctions.length > 0 || controllerNameMatcher) {\n                badStatements.forEach(function(item) {\n                    item.parents.forEach(function(parent) {\n                        if (isControllerFunction(parent)) {\n                            context.report(item.stmt, 'You should not set properties on $scope in controllers. Use controllerAs syntax and add data to \"this\"');\n                        }\n                    });\n                });\n            }\n        }\n\n        return {\n            // Looking for .controller() calls here and getting the associated controller function\n            'CallExpression:exit': function(node) {\n                if (utils.isAngularControllerDeclaration(node)) {\n                    controllerFunctions.push(utils.getControllerDefinition(context, node));\n                }\n            },\n            // statements are checked here for bad uses of $scope\n            ExpressionStatement: function(stmt) {\n                if (stmt.expression.type === 'AssignmentExpression' &&\n                    stmt.expression.left.object &&\n                    stmt.expression.left.object.name === '$scope' &&\n                    utils.scopeProperties.indexOf(stmt.expression.left.property.name) < 0) {\n                    badStatements.push({parents: context.getAncestors(), stmt: stmt});\n                } else if (stmt.expression.type === 'CallExpression' &&\n                    stmt.expression.callee.object &&\n                    stmt.expression.callee.object.name === '$scope' &&\n                    utils.scopeProperties.indexOf(stmt.expression.callee.property.name) < 0) {\n                    badStatements.push({parents: context.getAncestors(), stmt: stmt});\n                }\n            },\n            'Program:exit': function() {\n                reportBadUses();\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/controller-name.js":"/**\n * require and specify a prefix for all controller names\n *\n * All your controllers should have a name starting with the parameter you can define in your config object.\n * The second parameter can be a Regexp wrapped in quotes.\n * (\"controller-name\":  [2, \"ng\"])\n *\n * @styleguideReference {johnpapa} `y123` Controller Names\n * @styleguideReference {johnpapa} `y124` Controller Name Suffix\n * @version 0.1.0\n * @category naming\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: [\n            {\n                type: 'string'\n            }\n        ]\n    },\n    create: function(context) {\n        return {\n\n            CallExpression: function(node) {\n                var prefix = context.options[0] || '/^[A-Z][a-zA-Z0-9]*Controller$/';\n                var convertedPrefix; // convert string from JSON .eslintrc to regex\n\n                convertedPrefix = utils.convertPrefixToRegex(prefix);\n\n                var callee = node.callee;\n                if (callee.type === 'MemberExpression' && callee.property.name === 'controller') {\n                    /**\n                     * Allow the usage of element.controller() and element.controller('directiveName') in unittests\n                     */\n                    if (node.arguments.length < 2) {\n                        return;\n                    }\n\n                    var name = node.arguments[0].value;\n\n                    if (name !== undefined && !convertedPrefix.test(name)) {\n                        if (typeof prefix === 'string' && !utils.isStringRegexp(prefix)) {\n                            context.report(node, 'The {{controller}} controller should be prefixed by {{prefix}}', {\n                                controller: name,\n                                prefix: prefix\n                            });\n                        } else {\n                            context.report(node, 'The {{controller}} controller should follow this pattern: {{prefix}}', {\n                                controller: name,\n                                prefix: prefix.toString()\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/deferred.js":"/**\n * use `$q(function(resolve, reject){})` instead of `$q.deferred`\n *\n * When you want to create a new promise, you should not use the $q.deferred anymore.\n * Prefer the new syntax : $q(function(resolve, reject){})\n * @version 0.1.0\n * @category bestPractice\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        return {\n\n            MemberExpression: function(node) {\n                if (node.object.type === 'Identifier' && utils.isAngularServiceImport(node.object.name, '$q')) {\n                    if (node.property.type === 'Identifier' && node.property.name === 'defer') {\n                        context.report(node, 'You should not create a new promise with this syntax. Use the $q(function(resolve, reject) {}) syntax.', {});\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/definedundefined.js":"/**\n * use `angular.isDefined` and `angular.isUndefined` instead of other undefined checks\n *\n * You should use the angular.isUndefined or angular.isDefined methods instead of using the keyword undefined.\n * We also check the use of !angular.isUndefined and !angular.isDefined (should prefer the reverse function)\n *\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        function isCompareOperator(operator) {\n            return operator === '===' || operator === '!==' || operator === '==' || operator === '!=';\n        }\n        function reportError(node) {\n            context.report(node, 'You should not use directly the \"undefined\" keyword. Prefer ' +\n                'angular.isUndefined or angular.isDefined', {});\n        }\n        /**\n        *    Rule that check if we use angular.is(Un)defined() instead of the undefined keyword\n        */\n        return {\n            MemberExpression: function(node) {\n                if (node.object.name === 'angular' &&\n                    node.parent !== undefined &&\n                    node.parent.parent !== undefined &&\n                    node.parent.parent.operator === '!') {\n                    if (node.property.name === 'isDefined') {\n                        context.report(node, 'Instead of !angular.isDefined, you can use the out-of-box angular.isUndefined method', {});\n                    } else if (node.property.name === 'isUndefined') {\n                        context.report(node, 'Instead of !angular.isUndefined, you can use the out-of-box angular.isDefined method', {});\n                    }\n                }\n            },\n            BinaryExpression: function(node) {\n                if (isCompareOperator(node.operator)) {\n                    if (utils.isTypeOfStatement(node.left) && node.right.value === 'undefined') {\n                        reportError(node);\n                    } else if (utils.isTypeOfStatement(node.right) && node.left.value === 'undefined') {\n                        reportError(node);\n                    } else if (node.left.type === 'Identifier' && node.left.name === 'undefined') {\n                        reportError(node);\n                    } else if (node.right.type === 'Identifier' && node.right.name === 'undefined') {\n                        reportError(node);\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/di-order.js":"/**\n * require DI parameters to be sorted alphabetically\n *\n * Injected dependencies should be sorted alphabetically.\n * If the second parameter is set to false, values which start and end with an underscore those underscores are stripped.\n * This means for example that `_$httpBackend_` goes before `_$http_`.\n *\n * @version 0.6.0\n * @category conventions\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar angularRule = require('./utils/angular-rule');\nvar caseSensitive = 'case_sensitive';\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'boolean'\n        }, {\n            type: 'string'\n        }]\n    },\n    create: angularRule(function(context) {\n        var stripUnderscores = context.options[0] !== false;\n        var caseSensitiveOpt = (context.options[1] || caseSensitive) === caseSensitive;\n\n        function checkOrder(callee, fn) {\n            if (!fn || !fn.params) {\n                return;\n            }\n            var args = fn.params.map(function(arg) {\n                var formattedArg = arg.name;\n                if (stripUnderscores) {\n                    formattedArg = formattedArg.replace(/^_(.+)_$/, '$1');\n                }\n                return caseSensitiveOpt ? formattedArg : formattedArg.toLowerCase();\n            });\n            var sortedArgs = args.slice().sort();\n            sortedArgs.some(function(value, index) {\n                if (args.indexOf(value) !== index) {\n                    context.report(fn, 'Injected values should be sorted alphabetically');\n                    return true;\n                }\n            });\n        }\n\n        return {\n            'angular?animation': checkOrder,\n            'angular?config': checkOrder,\n            'angular?controller': checkOrder,\n            'angular?directive': checkOrder,\n            'angular?factory': checkOrder,\n            'angular?filter': checkOrder,\n            'angular?inject': checkOrder,\n            'angular?run': checkOrder,\n            'angular?service': checkOrder,\n            'angular?provider': function(callee, providerFn, $get) {\n                checkOrder(null, providerFn);\n                checkOrder(null, $get);\n            }\n        };\n    })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/di-unused.js":"/**\n * disallow unused DI parameters\n *\n * Unused dependencies should not be injected.\n *\n * @version 0.8.0\n * @category bestPractice\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar angularRule = require('./utils/angular-rule');\n\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: angularRule(function(context) {\n        // Keeps track of visited scopes in the collectAngularScopes function to prevent infinite recursion on circular references.\n        var visitedScopes = [];\n\n        // This collects the variable scopes for the injectible functions which have been collected.\n        function collectAngularScopes(scope) {\n            if (visitedScopes.indexOf(scope) === -1) {\n                visitedScopes.push(scope);\n                scope.childScopes.forEach(function(child) {\n                    collectAngularScopes(child);\n                });\n            }\n        }\n\n        function reportUnusedVariables(callee, fn) {\n            if (!fn) {\n                return;\n            }\n            visitedScopes.some(function(scope) {\n                if (scope.block !== fn) {\n                    return;\n                }\n                scope.variables.forEach(function(variable) {\n                    if (variable.name === 'arguments') {\n                        return;\n                    }\n                    if (fn.params.indexOf(variable.identifiers[0]) === -1) {\n                        return;\n                    }\n                    if (variable.references.length === 0) {\n                        context.report(fn, 'Unused injected value {{name}}', variable);\n                    }\n                });\n                return true;\n            });\n        }\n\n        return {\n            'angular?animation': reportUnusedVariables,\n            'angular?config': reportUnusedVariables,\n            'angular?controller': reportUnusedVariables,\n            'angular?directive': reportUnusedVariables,\n            'angular?factory': reportUnusedVariables,\n            'angular?filter': reportUnusedVariables,\n            'angular?inject': reportUnusedVariables,\n            'angular?run': reportUnusedVariables,\n            'angular?service': reportUnusedVariables,\n            'angular?provider': function(callee, providerFn, $get) {\n                reportUnusedVariables(null, providerFn);\n                reportUnusedVariables(null, $get);\n            },\n\n            // Actually find and report unused injected variables.\n            'Program:exit': function() {\n                var globalScope = context.getScope();\n                collectAngularScopes(globalScope);\n            }\n        };\n    })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/di.js":"/**\n * require a consistent DI syntax\n *\n * All your DI should use the same syntax : the Array, function, or $inject syntaxes (\"di\":  [2, \"array, function, or $inject\"])\n *\n * @version 0.1.0\n * @category conventions\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nvar angularRule = require('./utils/angular-rule');\n\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            enum: [\n                'function',\n                'array',\n                '$inject'\n            ]\n        }, {\n            type: 'object',\n            properties: {\n                matchNames: {\n                    type: 'boolean'\n                }\n            }\n        }]\n    },\n    create: angularRule(function(context) {\n        var syntax = context.options[0] || 'function';\n\n        var extra = context.options[1] || {};\n        var matchNames = extra.matchNames !== false;\n\n        function report(node) {\n            context.report(node, 'You should use the {{syntax}} syntax for DI', {\n                syntax: syntax\n            });\n        }\n\n        var $injectProperties = {};\n\n        function maybeNoteInjection(node) {\n            if (syntax === '$inject' && node.left && node.left.property &&\n                ((utils.isLiteralType(node.left.property) && node.left.property.value === '$inject') ||\n                    (utils.isIdentifierType(node.left.property) && node.left.property.name === '$inject'))) {\n                $injectProperties[node.left.object.name] = node.right;\n            }\n        }\n\n        function checkDi(callee, fn) {\n            if (!fn) {\n                return;\n            }\n\n            if (syntax === 'array') {\n                if (utils.isArrayType(fn.parent)) {\n                    if (fn.parent.elements.length - 1 !== fn.params.length) {\n                        context.report(fn, 'The signature of the method is incorrect', {});\n                        return;\n                    }\n\n                    if (matchNames) {\n                        var invalidArray = fn.params.filter(function(e, i) {\n                            return e.name !== fn.parent.elements[i].value;\n                        });\n                        if (invalidArray.length > 0) {\n                            context.report(fn, 'You have an error in your DI configuration. Each items of the array should match exactly one function parameter', {});\n                            return;\n                        }\n                    }\n                } else {\n                    if (fn.params.length === 0) {\n                        return;\n                    }\n                    report(fn);\n                }\n            }\n\n            if (syntax === 'function') {\n                if (utils.isArrayType(fn.parent)) {\n                    report(fn);\n                }\n            }\n\n            if (syntax === '$inject') {\n                if (fn && fn.id && utils.isIdentifierType(fn.id)) {\n                    var $injectArray = $injectProperties[fn.id.name];\n\n                    if ($injectArray && utils.isArrayType($injectArray)) {\n                        if ($injectArray.elements.length !== fn.params.length) {\n                            context.report(fn, 'The signature of the method is incorrect', {});\n                            return;\n                        }\n\n                        if (matchNames) {\n                            var invalidInjectArray = fn.params.filter(function(e, i) {\n                                return e.name !== $injectArray.elements[i].value;\n                            });\n                            if (invalidInjectArray.length > 0) {\n                                context.report(fn, 'You have an error in your DI configuration. Each items of the array should match exactly one function parameter', {});\n                                return;\n                            }\n                        }\n                    } else if (fn.params.length > 0) {\n                        report(fn);\n                    }\n                } else if (fn.params && fn.params.length !== 0) {\n                    report(fn);\n                }\n            }\n        }\n\n        return {\n            'angular?animation': checkDi,\n            'angular?config': checkDi,\n            'angular?controller': checkDi,\n            'angular?directive': checkDi,\n            'angular?factory': checkDi,\n            'angular?filter': checkDi,\n            'angular?inject': checkDi,\n            'angular?run': checkDi,\n            'angular?service': checkDi,\n            'angular?provider': function(callee, providerFn, $get) {\n                checkDi(null, providerFn);\n                checkDi(null, $get);\n            },\n            AssignmentExpression: function(node) {\n                maybeNoteInjection(node);\n            }\n        };\n    })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/directive-name.js":"/**\n * require and specify a prefix for all directive names\n *\n * All your directives should have a name starting with the parameter you can define in your config object.\n * The second parameter can be a Regexp wrapped in quotes.\n * You can not prefix your directives by \"ng\" (reserved keyword for AngularJS directives) (\"directive-name\":  [2, \"ng\"])\n *\n * @styleguideReference {johnpapa} `y073` Provide a Unique Directive Prefix\n * @styleguideReference {johnpapa} `y126` Directive Component Names\n * @version 0.1.0\n * @category naming\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: ['string', 'object']\n        }]\n    },\n    create: function(context) {\n        if (context.settings.angular === 2) {\n            return {};\n        }\n\n        return {\n\n            CallExpression: function(node) {\n                var prefix = context.options[0];\n                var convertedPrefix; // convert string from JSON .eslintrc to regex\n\n                if (prefix === undefined) {\n                    return;\n                }\n\n                convertedPrefix = utils.convertPrefixToRegex(prefix);\n\n                if (utils.isAngularDirectiveDeclaration(node)) {\n                    var name = node.arguments[0].value;\n\n                    if (name !== undefined && name.indexOf('ng') === 0) {\n                        context.report(node, 'The {{directive}} directive should not start with \"ng\". This is reserved for AngularJS directives', {\n                            directive: name\n                        });\n                    } else if (name !== undefined && !convertedPrefix.test(name)) {\n                        if (typeof prefix === 'string' && !utils.isStringRegexp(prefix)) {\n                            context.report(node, 'The {{directive}} directive should be prefixed by {{prefix}}', {\n                                directive: name,\n                                prefix: prefix\n                            });\n                        } else {\n                            context.report(node, 'The {{directive}} directive should follow this pattern: {{prefix}}', {\n                                directive: name,\n                                prefix: prefix.toString()\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/directive-restrict.js":"/**\n * disallow any other directive restrict than 'A' or 'E'\n *\n * Not all directive restrictions may be desirable.\n * Also it might be desirable to define default restrictions, or explicitly not.\n * The default configuration limits the restrictions `AE` and disallows explicitly specifying a default.\n * (\"directive-restrict\": [0, {\"restrict\": \"AE\", \"explicit\": \"never\"}])\n *\n * @styleguideReference {johnpapa} `y074` Restrict to Elements and Attributes\n * @version 0.12.0\n * @category bestPractice\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'object',\n            properties: {\n                restrict: {\n                    type: 'string',\n                    pattern: '^A|C|E|(AC)|(CA)|(AE)|(EA)|(EC)|(CE)|(AEC)|(ACE)|(EAC)|(CAE)|(ACE)|(AEC)|(CAE)|(ACE)|(AEC)$'\n                },\n                explicit: {\n                    enum: ['always', 'never']\n                }\n            }\n        }]\n    },\n    create: function(context) {\n        var options = context.options[0] || {};\n        var restrictOpt = options.restrict || 'AE';\n        var explicitRestrict = options.explicit === 'always';\n        var restrictChars = restrictOpt.split('');\n\n        // Example RegExp for AE: /^A?E?$/\n        var restrictRegExp = new RegExp('^' + restrictChars.join('?') + '?$');\n        var foundDirectives = [];\n        var checkedDirectives = [];\n        var defaultRestrictions = ['AE', 'EA'];\n\n        function checkLiteralNode(node) {\n            if (node.type !== 'Literal') {\n                return;\n            }\n            var directiveNode;\n            context.getAncestors().some(function(ancestor) {\n                if (utils.isAngularDirectiveDeclaration(ancestor)) {\n                    directiveNode = ancestor;\n                    return true;\n                }\n            });\n            // The restrict property was not defined inside of a directive.\n            if (!directiveNode) {\n                return;\n            }\n            if (!explicitRestrict && defaultRestrictions.indexOf(node.value) !== -1) {\n                context.report(node, 'No need to explicitly specify a default directive restriction');\n                return;\n            }\n\n            if (!restrictRegExp.test(node.value)) {\n                context.report(directiveNode, 'Disallowed directive restriction. It must be one of {{allowed}} in that order', {\n                    allowed: restrictOpt\n                });\n            }\n\n            checkedDirectives.push(directiveNode);\n        }\n\n        return {\n            CallExpression: function(node) {\n                if (utils.isAngularDirectiveDeclaration(node)) {\n                    foundDirectives.push(node);\n                }\n            },\n            AssignmentExpression: function(node) {\n                // Only check for literal member property assignments.\n                if (node.left.type !== 'MemberExpression') {\n                    return;\n                }\n                // Only check setting properties named 'restrict'.\n                if (node.left.property.name !== 'restrict') {\n                    return;\n                }\n                checkLiteralNode(node.right);\n            },\n            Property: function(node) {\n                // This only checks for objects which have defined a literal restrict property.\n                if (node.key.name !== 'restrict') {\n                    return;\n                }\n                checkLiteralNode(node.value);\n            },\n            'Program:exit': function() {\n                if (explicitRestrict) {\n                    foundDirectives.filter(function(directive) {\n                        return checkedDirectives.indexOf(directive) < 0;\n                    }).forEach(function(directiveNode) {\n                        context.report(directiveNode, 'Missing directive restriction');\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/document-service.js":"/**\n * use `$document` instead of `document`\n *\n * Instead of the default document object, you should prefer the AngularJS wrapper service $document.\n *\n * @styleguideReference {johnpapa} `y180` Angular $ Wrapper Services - $document and $window\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        return {\n            MemberExpression: function(node) {\n                if (node.object.name === 'document' || (node.object.name === 'window' && node.property.name === 'document')) {\n                    context.report(node, 'You should use the $document service instead of the default document object', {});\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/dumb-inject.js":"/**\n * unittest `inject` functions should only consist of assignments from injected values to describe block variables\n *\n * `inject` functions in unittests should only contain a sorted mapping of injected values to values in the `describe` block with matching names.\n * This way the dependency injection setup is separated from the other setup logic, improving readability of the test.\n *\n * @version 0.15.0\n * @category conventions\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar angularRule = require('./utils/angular-rule');\n\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: angularRule(function(context) {\n        function report(node, name) {\n            context.report(node, 'inject functions may only consist of assignments in the form {{name}} = _{{name}}_', {\n                name: name || 'myService'\n            });\n        }\n\n        return {\n            'angular?inject': function(callExpression, fn) {\n                if (!fn) {\n                    return;\n                }\n                var valid = [];\n                // Report bad statement types\n                fn.body.body.forEach(function(statement) {\n                    if (statement.type !== 'ExpressionStatement') {\n                        return report(statement);\n                    }\n                    if (statement.expression.type !== 'AssignmentExpression') {\n                        return report(statement);\n                    }\n                    if (statement.expression.right.type !== 'Identifier') {\n                        return report(statement);\n                    }\n                    // From this point there is more context on what to report.\n                    var name = statement.expression.right.name.replace(/^_(.+)_$/, '$1');\n                    if (statement.expression.left.type !== 'Identifier') {\n                        return report(statement, name);\n                    }\n                    if (statement.expression.right.name !== '_' + name + '_') {\n                        return report(statement, name);\n                    }\n                    if (statement.expression.left.name !== name) {\n                        return report(statement, name);\n                    }\n                    // Register valid statements for sort order validation\n                    valid.push(statement);\n                });\n                // Validate the sorting order\n                var lastValid;\n                valid.forEach(function(statement) {\n                    if (!lastValid) {\n                        lastValid = statement.expression.left.name;\n                        return;\n                    }\n                    if (statement.expression.left.name.localeCompare(lastValid) !== -1) {\n                        lastValid = statement.expression.left.name;\n                        return;\n                    }\n                    context.report(statement, \"'{{current}}' must be sorted before '{{previous}}'\", {\n                        current: statement.expression.left.name,\n                        previous: lastValid\n                    });\n                });\n            }\n        };\n    })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/empty-controller.js":"/**\n * disallow empty controllers\n *\n * If you have one empty controller, maybe you have linked it in your Router configuration or in one of your views.\n * You can remove this declaration because this controller is useless\n *\n * @version 0.1.0\n * @category bestPractice\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        function report(node, name) {\n            context.report(node, 'The {{ctrl}} controller is useless because empty. You can remove it from your Router configuration or in one of your view', {\n                ctrl: name\n            });\n        }\n\n        return {\n\n            CallExpression: function(node) {\n                if (utils.isAngularControllerDeclaration(node)) {\n                    var name = node.arguments[0].value;\n\n                    var fn = node.arguments[1];\n                    if (utils.isArrayType(node.arguments[1])) {\n                        fn = node.arguments[1].elements[node.arguments[1].elements.length - 1];\n                    }\n                    if (utils.isFunctionType(fn) && utils.isEmptyFunction(fn)) {\n                        report(node, name);\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/factory-name.js":"/**\n * require and specify a prefix for all factory names\n *\n * All your factorys should have a name starting with the parameter you can define in your config object.\n * The second parameter can be a Regexp wrapped in quotes.\n * You can not prefix your factorys by \"$\" (reserved keyword for AngularJS services) (\"factory-name\":  [2, \"ng\"])\n **\n * @styleguideReference {johnpapa} `y125` Naming - Factory and Service Names\n * @version 0.1.0\n * @category naming\n */\n'use strict';\n\n\nvar utils = require('./utils/utils');\n\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: ['string', 'object']\n        }, {\n            type: 'object'\n        }]\n    },\n    create: function(context) {\n        return {\n\n            CallExpression: function(node) {\n                var prefix = context.options[0];\n                var convertedPrefix; // convert string from JSON .eslintrc to regex\n                var isFactory;\n\n                if (prefix === undefined) {\n                    return;\n                }\n\n                convertedPrefix = utils.convertPrefixToRegex(prefix);\n                isFactory = utils.isAngularFactoryDeclaration(node);\n\n                if (isFactory) {\n                    var name = node.arguments[0].value;\n\n                    if (name !== undefined && name.indexOf('$') === 0) {\n                        context.report(node, 'The {{factory}} factory should not start with \"$\". This is reserved for AngularJS services', {\n                            factory: name\n                        });\n                    } else if (name !== undefined && !convertedPrefix.test(name)) {\n                        if (typeof prefix === 'string' && !utils.isStringRegexp(prefix)) {\n                            context.report(node, 'The {{factory}} factory should be prefixed by {{prefix}}', {\n                                factory: name,\n                                prefix: prefix\n                            });\n                        } else {\n                            context.report(node, 'The {{factory}} factory should follow this pattern: {{prefix}}', {\n                                factory: name,\n                                prefix: prefix.toString()\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/file-name.js":"/**\n * require and specify a consistent component name pattern\n *\n * All your file names should match the angular component name.\n * The second parameter can be a config object [2, {nameStyle: 'dash', typeSeparator: 'dot', ignoreTypeSuffix: true, ignorePrefix: 'ui'}] to match 'avenger-profile.directive.js' or 'avanger-api.service.js'.\n * Possible values for 'typeSeparator' and 'nameStyle' are 'dot', 'dash' and 'underscore'.\n * The options 'ignoreTypeSuffix' ignores camel cased suffixes like 'someController' or 'myService' and 'ignorePrefix' ignores namespace prefixes like 'ui'.\n *\n * The naming scheme is &lt;componentName&gt;&lt;typeSeparator&gt;&lt;componentType&gt;.js\n *\n * The *componentType* for all service types (service, factory, provider, value) is 'service'.\n * Since 1.5.0 it is possible to configure custom mappings for the *componentType*: {typeSeparator: 'dot', componentTypeMappings: {factory: 'factory', provider: 'provider'}.\n *\n * @styleguideReference {johnpapa} `y120` Naming - Naming Guidelines\n * @styleguideReference {johnpapa} `y121` Naming - Feature File Names\n * @version 0.7.0\n * @category naming\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar path = require('path');\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: ['object']\n        }]\n    },\n    create: (function() {\n        var fileEnding = '.js';\n\n        var separators = {\n            dot: '.',\n            dash: '-',\n            underscore: '_'\n        };\n\n        function createComponentTypeMappings(options) {\n            var componentTypeMappingOptions = options.componentTypeMappings || {};\n\n            return {\n                module: componentTypeMappingOptions.module || 'module',\n                controller: componentTypeMappingOptions.controller || 'controller',\n                directive: componentTypeMappingOptions.directive || 'directive',\n                filter: componentTypeMappingOptions.filter || 'filter',\n                service: componentTypeMappingOptions.service || 'service',\n                factory: componentTypeMappingOptions.factory || 'service',\n                provider: componentTypeMappingOptions.provider || 'service',\n                value: componentTypeMappingOptions.value || 'service',\n                constant: componentTypeMappingOptions.constant || 'constant',\n                component: componentTypeMappingOptions.component || 'component'\n            };\n        }\n\n        var filenameUtil = {\n            firstToUpper: function(value) {\n                return value[0].toUpperCase() + value.slice(1);\n            },\n            firstToLower: function(value) {\n                return value[0].toLowerCase() + value.slice(1);\n            },\n            removeTypeSuffix: function(name, type) {\n                var nameTypeLengthDiff = name.length - type.length;\n                if (nameTypeLengthDiff <= 0) {\n                    return name;\n                }\n                var typeCamelCase = this.firstToUpper(type);\n                if (name.indexOf(typeCamelCase) === nameTypeLengthDiff) {\n                    return name.slice(0, nameTypeLengthDiff);\n                }\n                return name;\n            },\n            removePrefix: function(name, options) {\n                var regName = '^' + options.ignorePrefix.replace(/[\\.]/g, '\\\\$&');\n                regName += options.ignorePrefix.indexOf('\\.') === -1 ? '[A-Z]' : '[a-zA-z]';\n                if (new RegExp(regName).test(name)) {\n                    return this.firstToLower(name.slice(options.ignorePrefix.length));\n                }\n                return name;\n            },\n            transformComponentName: function(name, options) {\n                var nameStyle = options.nameStyle;\n                var nameSeparator = separators[nameStyle];\n                if (nameSeparator) {\n                    var replacement = '$1' + nameSeparator + '$2';\n                    name = name.replace(/([a-z0-9])([A-Z])/g, replacement).toLowerCase();\n                }\n                return name;\n            },\n            createExpectedName: function(name, type, options) {\n                var typeSeparator = separators[options.typeSeparator];\n\n                if (options.ignoreTypeSuffix) {\n                    name = filenameUtil.removeTypeSuffix(name, type);\n                }\n                if (options.ignorePrefix && options.ignorePrefix.length > 0) {\n                    name = filenameUtil.removePrefix(name, options);\n                }\n                if (options.nameStyle) {\n                    name = filenameUtil.transformComponentName(name, options);\n                }\n                if (typeSeparator !== undefined) {\n                    name = name + typeSeparator + type;\n                }\n                if (options.casing === 'camel') {\n                    name = filenameUtil.firstToLower(name);\n                }\n                if (options.casing === 'pascal') {\n                    name = filenameUtil.firstToUpper(name);\n                }\n                return name + fileEnding;\n            }\n        };\n\n        return function(context) {\n            var options = context.options[0] || {};\n            var filename = path.basename(context.getFilename());\n            var componentTypeMappings = createComponentTypeMappings(options);\n\n            return {\n                CallExpression: function(node) {\n                    if (utils.isAngularComponent(node) && utils.isMemberExpression(node.callee)) {\n                        var name = node.arguments[0].value;\n                        var type = componentTypeMappings[node.callee.property.name];\n                        var expectedName;\n\n                        if (type === undefined || (type === 'service' && node.callee.object.name === '$provide')) {\n                            return;\n                        }\n\n                        if (!name) {\n                            return;\n                        }\n                        expectedName = filenameUtil.createExpectedName(name, type, options);\n\n                        if (expectedName !== filename) {\n                            context.report(node, 'Filename must be \"{{expectedName}}\"', {\n                                expectedName: expectedName\n                            });\n                        }\n                    }\n                }\n            };\n        };\n    }())\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/filter-name.js":"/**\n * require and specify a prefix for all filter names\n *\n * All your filters should have a name starting with the parameter you can define in your config object.\n * The second parameter can be a Regexp wrapped in quotes.\n * (\"filter-name\":  [2, \"ng\"])\n *\n * @version 0.1.0\n * @category naming\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: ['string', 'object']\n        }]\n    },\n    create: function(context) {\n        return {\n\n            CallExpression: function(node) {\n                var prefix = context.options[0];\n                var convertedPrefix; // convert string from JSON .eslintrc to regex;\n                if (prefix === undefined) {\n                    return;\n                }\n\n                convertedPrefix = utils.convertPrefixToRegex(prefix);\n\n                if (utils.isAngularFilterDeclaration(node)) {\n                    var name = node.arguments[0].value;\n\n                    if (name !== undefined && !convertedPrefix.test(name)) {\n                        if (typeof prefix === 'string' && !utils.isStringRegexp(prefix)) {\n                            context.report(node, 'The {{filter}} filter should be prefixed by {{prefix}}', {\n                                filter: name,\n                                prefix: prefix\n                            });\n                        } else {\n                            context.report(node, 'The {{filter}} filter should follow this pattern: {{prefix}}', {\n                                filter: name,\n                                prefix: prefix.toString()\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/foreach.js":"/**\n * use `angular.forEach` instead of native `Array.prototype.forEach`\n *\n * You should use the angular.forEach method instead of the default JavaScript implementation [].forEach.\n *\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        return {\n            MemberExpression: function(node) {\n                if (node.object.type === 'Identifier' && node.object.name !== 'angular' && node.property.name === 'forEach') {\n                    context.report(node, 'You should use the angular.forEach method', {});\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/function-type.js":"/**\n * require and specify a consistent function style for components\n *\n * Anonymous or named functions inside AngularJS components.\n * The first parameter sets which type of function is required and can be 'named' or 'anonymous'.\n * The second parameter is an optional list of angular object names.\n *\n * @linkDescription require and specify a consistent function style for components ('named' or 'anonymous')\n * @styleguideReference {johnpapa} `y024` Named vs Anonymous Functions\n * @version 0.1.0\n * @category conventions\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            enum: [\n                'named',\n                'anonymous'\n            ]\n        }, {\n            type: 'array',\n            items: {\n                type: 'string'\n            }\n        }]\n    },\n    create: function(context) {\n        var angularObjectList = ['animation', 'config', 'constant', 'controller', 'directive', 'factory', 'filter', 'provider', 'service', 'value', 'decorator'];\n        var configType = context.options[0] || 'anonymous';\n        var messageByConfigType = {\n            anonymous: 'Use anonymous functions instead of named function',\n            named: 'Use named functions instead of anonymous function'\n        };\n        var message = messageByConfigType[configType];\n\n        if (context.options[1]) {\n            angularObjectList = context.options[1];\n        }\n\n        function checkType(arg) {\n            return utils.isCallExpression(arg) ||\n                (configType === 'named' && (utils.isIdentifierType(arg) || utils.isNamedInlineFunction(arg))) ||\n                (configType === 'anonymous' && utils.isFunctionType(arg) && !utils.isNamedInlineFunction(arg));\n        }\n\n        return {\n\n            CallExpression: function(node) {\n                var callee = node.callee;\n                var angularObjectName = callee.property && callee.property.name;\n                var firstArgument = node.arguments[1];\n\n                if (utils.isAngularComponent(node) && callee.type === 'MemberExpression' && angularObjectList.indexOf(angularObjectName) >= 0) {\n                    if (checkType(firstArgument)) {\n                        return;\n                    }\n\n                    if (utils.isArrayType(firstArgument)) {\n                        var last = firstArgument.elements[firstArgument.elements.length - 1];\n                        if (checkType(last) || (!utils.isFunctionType(last) && !utils.isIdentifierType(last))) {\n                            return;\n                        }\n                    }\n\n                    context.report(node, message, {});\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/interval-service.js":"/**\n * use `$interval` instead of `setInterval`\n *\n * Instead of the default setInterval function, you should use the AngularJS wrapper service $interval\n *\n * @styleguideReference {johnpapa} `y181` Angular $ Wrapper Services - $timeout and $interval\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        var message = 'You should use the $interval service instead of the default window.setInterval method';\n\n        return {\n\n            MemberExpression: function(node) {\n                if (node.object.name === 'window' && node.property.name === 'setInterval') {\n                    context.report(node, message, {});\n                }\n            },\n\n            CallExpression: function(node) {\n                if (node.callee.name === 'setInterval') {\n                    context.report(node, message, {});\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/json-functions.js":"/**\n * enforce use of`angular.fromJson` and 'angular.toJson'\n *\n * You should use angular.fromJson or angular.toJson instead of JSON.parse and JSON.stringify\n *\n * @linkDescription use `angular.fromJson` and 'angular.toJson' instead of `JSON.parse` and `JSON.stringify`\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        return {\n\n            MemberExpression: function(node) {\n                if (node.object.name === 'JSON') {\n                    if (node.property.name === 'stringify') {\n                        context.report(node, 'You should use the angular.toJson method instead of JSON.stringify', {});\n                    } else if (node.property.name === 'parse') {\n                        context.report(node, 'You should use the angular.fromJson method instead of JSON.parse', {});\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/log.js":"/**\n * use the `$log` service instead of the `console` methods\n *\n * You should use $log service instead of console for the methods 'log', 'debug', 'error', 'info', 'warn'\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        var method = ['log', 'debug', 'error', 'info', 'warn'];\n\n        return {\n\n            MemberExpression: function(node) {\n                if (node.object.name === 'console' && method.indexOf(node.property.name) >= 0) {\n                    context.report(node, 'You should use the \"' + node.property.name + '\" method of the AngularJS Service $log instead of the console object');\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/module-dependency-order.js":"/**\n * require a consistent order of module dependencies\n *\n * Module dependencies should be sorted in a logical manner.\n * This rule provides two ways to sort modules, grouped or ungrouped.\n * In grouped mode the modules should be grouped in the order: standard modules - third party modules - custom modules.\n * The modules should be sorted alphabetically within its group.\n * A prefix can be specified to determine which prefix the custom modules have.\n * Without grouped set to `false` all dependencies combined should be sorted alphabetically.\n * ('module-dependency-order', [2, {grouped: true, prefix: \"app\"}])\n *\n * @version 0.12.0\n * @category conventions\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'object',\n            properties: {\n                grouped: {\n                    type: 'boolean'\n                },\n                prefix: {\n                    type: ['string', 'null']\n                }\n            }\n        }]\n    },\n    create: function(context) {\n        var options = context.options[0] || {};\n        var groupedMode = options.grouped !== false;\n        var moduleRegex;\n        if (groupedMode) {\n            moduleRegex = utils.convertPrefixToRegex(options.prefix);\n        }\n\n        var standard = [\n            // Libraries in the angular.js repository\n            'ng',\n            'ngAnimate',\n            'ngAria',\n            'ngCookies',\n            'ngLocale',\n            'ngMessageFormat',\n            'ngMessages',\n            'ngMock',\n            'ngResource',\n            'ngRoute',\n            'ngSanitize',\n            'ngTouch',\n\n            // Libraries maintained by the angular team, but in another repository\n            'ngMaterial',\n            'ngNewRouter'\n        ];\n\n        function checkLiteral(node) {\n            if (node && node.type !== 'Literal' && node.type !== 'Identifier') {\n                context.report(node, 'Unexpected non-literal or identifier value' + node.type);\n                return false;\n            }\n            if (!node) {\n                return false;\n            }\n            return true;\n        }\n\n        function checkCombined(deps) {\n            var lastCorrect;\n            deps.elements.forEach(function(node) {\n                if (!checkLiteral(node)) {\n                    return;\n                }\n                var value = node.value || node.name;\n                if (lastCorrect === undefined || lastCorrect.localeCompare(value) < 0) {\n                    lastCorrect = value;\n                } else {\n                    context.report(node, '{{current}} should be sorted before {{last}}', {\n                        current: value,\n                        last: lastCorrect\n                    });\n                }\n            });\n        }\n\n        function isStandardModule(value) {\n            return standard.indexOf(value) !== -1;\n        }\n\n        function isCustomModule(value) {\n            return moduleRegex && moduleRegex.test(value);\n        }\n\n        function checkGrouped(deps) {\n            var lastCorrect;\n            var group = 'standard';\n            deps.elements.forEach(function loop(node) {\n                if (!checkLiteral(node)) {\n                    return;\n                }\n                var value = node.value || node.name;\n                if (lastCorrect === undefined) {\n                    lastCorrect = value;\n                    if (isCustomModule(value)) {\n                        group = 'custom';\n                    } else if (standard.indexOf(value) === -1) {\n                        group = 'third party';\n                    }\n                    return;\n                }\n                if (group === 'standard') {\n                    if (isStandardModule(value)) {\n                        if (lastCorrect.localeCompare(value) > 0) {\n                            context.report(node, '{{current}} should be sorted before {{last}}', {\n                                current: value,\n                                last: lastCorrect\n                            });\n                        } else {\n                            lastCorrect = value;\n                        }\n                    } else {\n                        if (isCustomModule(value)) {\n                            group = 'custom';\n                        } else {\n                            group = 'third party';\n                        }\n                        lastCorrect = value;\n                    }\n                }\n                if (group === 'third party') {\n                    if (isStandardModule(value)) {\n                        context.report(node, '{{current}} is a standard module and should be sorted before {{last}}', {\n                            current: value,\n                            last: lastCorrect\n                        });\n                    } else if (isCustomModule(value)) {\n                        group = 'custom';\n                        lastCorrect = value;\n                    } else if (lastCorrect.localeCompare(value) > 0) {\n                        context.report(node, '{{current}} should be sorted before {{last}}', {\n                            current: value,\n                            last: lastCorrect\n                        });\n                    } else {\n                        lastCorrect = value;\n                    }\n                }\n                if (group === 'custom') {\n                    if (isStandardModule(value)) {\n                        context.report(node, '{{current}} is a standard module and should be sorted before {{last}}', {\n                            current: value,\n                            last: lastCorrect\n                        });\n                    } else if (!isCustomModule(value)) {\n                        context.report(node, '{{current}} is a third party module and should be sorted before {{last}}', {\n                            current: value,\n                            last: lastCorrect\n                        });\n                    }\n                }\n            });\n        }\n\n        return {\n            CallExpression: function(node) {\n                if (!utils.isAngularModuleDeclaration(node)) {\n                    return;\n                }\n                var deps = node.arguments[1];\n                if (deps.type !== 'ArrayExpression') {\n                    context.report(deps, 'Dependencies should be a literal array');\n                    return;\n                }\n                if (groupedMode) {\n                    checkGrouped(deps);\n                } else {\n                    checkCombined(deps);\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/module-getter.js":"/**\n * enforce to reference modules with the getter syntax\n *\n * When using a module, avoid using a variable and instead use chaining with the getter syntax\n *\n * @linkDescription disallow to reference modules with variables and require to use the getter syntax instead `angular.module('myModule')`\n * @styleguideReference {johnpapa} `y022` Module - Getters\n * @version 0.1.0\n * @category possibleError\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        return {\n\n            ExpressionStatement: function(node) {\n                if ((utils.isAngularControllerDeclaration(node.expression) ||\n                    utils.isAngularFilterDeclaration(node.expression) ||\n                    utils.isAngularServiceDeclaration(node.expression) ||\n                    utils.isAngularFactoryDeclaration(node.expression) ||\n                    utils.isAngularConstantDeclaration(node.expression) ||\n                    utils.isAngularValueDeclaration(node.expression) ||\n                    utils.isAngularDirectiveDeclaration(node.expression) ||\n                    utils.isAngularRunSection(node.expression) ||\n                    utils.isAngularConfigSection(node.expression)) &&\n\n                    !utils.isAngularModuleDeclaration(node.expression)) {\n                    var calleeObject = node.expression.callee.object;\n\n                    while (calleeObject !== undefined && calleeObject.type === 'CallExpression' && !utils.isAngularModuleGetter(calleeObject)) {\n                        calleeObject = calleeObject.callee.object;\n                    }\n                    if (!(calleeObject !== undefined && calleeObject.type === 'CallExpression' && utils.isAngularModuleGetter(calleeObject))) {\n                        context.report(node, 'Avoid using a variable and instead use chaining with the getter syntax.');\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/module-name.js":"/**\n * require and specify a prefix for all module names\n *\n * When you create a new module, its name should start with the parameter you can define in your config object.\n * The second parameter can be a Regexp wrapped in quotes.\n * You can not prefix your modules by \"ng\" (reserved keyword for AngularJS modules) (\"module-name\":  [2, \"ng\"])\n *\n * @styleguideReference {johnpapa} `y127` Naming - Modules\n * @version 0.1.0\n * @category naming\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: ['string', 'object']\n        }]\n    },\n    create: function(context) {\n        return {\n\n            CallExpression: function(node) {\n                var prefix = context.options[0];\n                var convertedPrefix; // convert string from JSON .eslintrc to regex\n\n                if (prefix === undefined) {\n                    return;\n                }\n\n                convertedPrefix = utils.convertPrefixToRegex(prefix);\n\n                if (utils.isAngularModuleDeclaration(node)) {\n                    var name = node.arguments[0].value;\n\n                    if (name !== undefined && name.indexOf('ng') === 0) {\n                        context.report(node, 'The {{module}} module should not start with \"ng\". This is reserved for AngularJS modules', {\n                            module: name\n                        });\n                    } else if (name !== undefined && !convertedPrefix.test(name)) {\n                        if (typeof prefix === 'string' && !utils.isStringRegexp(prefix)) {\n                            context.report(node, 'The {{module}} module should be prefixed by {{prefix}}', {\n                                module: name,\n                                prefix: prefix\n                            });\n                        } else {\n                            context.report(node, 'The {{module}} module should follow this pattern: {{prefix}}', {\n                                module: name,\n                                prefix: prefix.toString()\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/module-setter.js":"/**\n * disallow to assign modules to variables\n *\n * Declare modules without a variable using the setter syntax.\n *\n * @linkDescription disallow to assign modules to variables (linked to [module-getter](docs/module-getter.md)\n * @styleguideReference {johnpapa} `y021` Module - Definitions (aka Setters)\n * @version 0.1.0\n * @category possibleError\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        return {\n\n            VariableDeclaration: function(node) {\n                var variableDeclarator = node.declarations[0];\n                var rightExpression;\n\n                if (variableDeclarator.init) {\n                    rightExpression = variableDeclarator.init;\n\n                    if (rightExpression.arguments && utils.isAngularModuleDeclaration(rightExpression)) {\n                        context.report(rightExpression, 'Declare modules without a variable using the setter syntax.');\n                    }\n                }\n            },\n            AssignmentExpression: function(node) {\n                if (node.right.arguments && utils.isAngularModuleDeclaration(node.right)) {\n                    context.report(node.right, 'Declare modules without a variable using the setter syntax.');\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/no-angular-mock.js":"/**\n * require to use `angular.mock` methods directly\n *\n * All methods defined in the angular.mock object are also available in the object window.\n * So you can remove angular.mock from your code\n *\n * @version 0.2.0\n * @category angularWrapper\n *\n * NOTE: While this rule does enforce the use of `angular.mock` methods to be used\n * in the object window, the `eslint` rule no-undef (http://eslint.org/docs/rules/no-undef.html)\n * may prevent you from using undefined global variables such as those provided by\n * `angular.mock`. The current fix for this is to simply add all of the `angular.mock`\n * object methods to your `eslint` globals:\n *\n * \"globals\": {\n *   \"angular\": false,\n *   \"module\": false,\n *   \"inject\": false\n * }\n *\n * At this time (01/06/2016), there is no way to add globals for a specific environment\n * in `eslint`, although it is an accepted feature (https://github.com/eslint/eslint/issues/4782)\n * and should exist sometime in the future.\n *\n * Check here(https://github.com/Gillespie59/eslint-plugin-angular/issues/330)\n * for more information on this topic.\n *\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        return {\n\n            MemberExpression: function(node) {\n                if (node.object.type === 'Identifier' && node.object.name === 'angular' &&\n                    node.property.type === 'Identifier' && node.property.name === 'mock') {\n                    if (node.parent.type === 'MemberExpression' && node.parent.property.type === 'Identifier') {\n                        context.report(node, 'You should use the \"{{method}}\" method available in the window object.', {\n                            method: node.parent.property.name\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/no-controller.js":"/**\n * disallow use of controllers (according to the component first pattern)\n *\n * According to the Component-First pattern, we should avoid the use of AngularJS controller.\n *\n * @version 0.9.0\n * @category bestPractice\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        return {\n\n            CallExpression: function(node) {\n                if (utils.isAngularControllerDeclaration(node)) {\n                    context.report(node, 'Based on the Component-First Pattern, you should avoid the use of controllers', {});\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/no-cookiestore.js":"/**\n * use `$cookies` instead of `$cookieStore`\n *\n * In Angular 1.4, the $cookieStore service is now deprected.\n * Please use the $cookies service instead\n *\n * @version 0.3.0\n * @category deprecatedAngularFeature\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        return {\n\n            MemberExpression: function(node) {\n                if (node.object && node.object.name === '$cookieStore') {\n                    context.report(node, 'Since Angular 1.4, the $cookieStore service is deprecated. Please use now the $cookies service.', {});\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/no-directive-replace.js":"/**\n * disallow the deprecated directive replace property\n *\n * This rule disallows the replace attribute in a directive definition object.\n * The replace property of a directive definition object is deprecated since angular 1.3 ([latest angular docs](https://docs.angularjs.org/api/ng/service/$compile).\n *\n * The option `ignoreReplaceFalse` let you ignore directive definitions with replace set to false.\n *\n * @version 0.15.0\n * @category deprecatedAngularFeature\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar angularRule = require('./utils/angular-rule');\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'object',\n            properties: {\n                ignoreReplaceFalse: {\n                    type: 'boolean'\n                }\n            }\n        }]\n    },\n    create: angularRule(function(context) {\n        var options = context.options[0] || {};\n        var ignoreReplaceFalse = !!options.ignoreReplaceFalse;\n\n        var potentialReplaceNodes = {};\n\n        function addPotentialReplaceNode(variableName, node) {\n            var nodeList = potentialReplaceNodes[variableName] || [];\n\n            nodeList.push({\n                name: variableName,\n                node: node,\n                block: context.getScope().block.body\n            });\n\n            potentialReplaceNodes[variableName] = nodeList;\n        }\n\n        return {\n            'angular?directive': function(callExpressionNode, fnNode) {\n                if (!fnNode || !fnNode.body) {\n                    return;\n                }\n                fnNode.body.body.forEach(function(statement) {\n                    if (statement.type === 'ReturnStatement') {\n                        // get potential replace node by argument name of empty string for object expressions\n                        var potentialNodes = potentialReplaceNodes[statement.argument.name || ''];\n                        if (!potentialNodes) {\n                            return;\n                        }\n                        potentialNodes.forEach(function(report) {\n                            // only reports nodes that belong to the same expression\n                            if (report.block === statement.parent) {\n                                context.report(report.node, 'Directive definition property replace is deprecated.');\n                            }\n                        });\n                    }\n                });\n            },\n            AssignmentExpression: function(node) {\n                // Only check for literal member property assignments.\n                if (node.left.type !== 'MemberExpression') {\n                    return;\n                }\n                // Only check setting properties named 'replace'.\n                if (node.left.property.name !== 'replace') {\n                    return;\n                }\n                if (ignoreReplaceFalse && node.right.value === false) {\n                    return;\n                }\n                addPotentialReplaceNode(node.left.object.name, node);\n            },\n            Property: function(node) {\n                // This only checks for objects which have defined a literal restrict property.\n                if (node.key.name !== 'replace') {\n                    return;\n                }\n                if (ignoreReplaceFalse === true && node.value.value === false) {\n                    return;\n                }\n\n                // assumption: Property always belongs to a ObjectExpression\n                var objectExpressionParent = node.parent.parent;\n\n                // add to potential replace nodes if the object is defined in a variable\n                if (objectExpressionParent.type === 'VariableDeclarator') {\n                    addPotentialReplaceNode(objectExpressionParent.id.name, node);\n                }\n\n                // report directly if object is part of a return statement and inside a directive body\n                if (objectExpressionParent.type === 'ReturnStatement') {\n                    addPotentialReplaceNode('', node);\n                }\n            }\n        };\n    })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/no-http-callback.js":"/**\n * disallow the `$http` methods `success()` and `error()`\n *\n * Disallow the $http success and error function.\n * Instead the standard promise API should be used.\n *\n * @version 0.12.0\n * @category deprecatedAngularFeature\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        var httpMethods = [\n            'delete',\n            'get',\n            'head',\n            'jsonp',\n            'patch',\n            'post',\n            'put'\n        ];\n\n        function isHttpCall(node) {\n            if (node.callee.type === 'MemberExpression') {\n                return httpMethods.indexOf(node.callee.property.name) !== -1 ||\n                    (node.callee.object.type === 'CallExpression' && isHttpCall(node.callee.object));\n            }\n            if (node.callee.type === 'Identifier') {\n                return node.callee.name === '$http';\n            }\n        }\n\n        return {\n            CallExpression: function(node) {\n                if (node.callee.type !== 'MemberExpression') {\n                    return;\n                }\n                if (node.callee.property.name === 'success' && isHttpCall(node)) {\n                    return context.report(node, '$http success is deprecated. Use then instead');\n                }\n                if (node.callee.property.name === 'error' && isHttpCall(node)) {\n                    context.report(node, '$http error is deprecated. Use then or catch instead');\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/no-inline-template.js":"/**\n * disallow the use of inline templates\n *\n * Instead of using inline HTML templates, it is better to load the HTML from an external file.\n * Simple HTML templates are accepted by default.\n * ('no-inline-template': [0, {allowSimple: true}])\n *\n * @version 0.12.0\n * @category bestPractice\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            allowSimple: {\n                type: 'boolean'\n            }\n        }]\n    },\n    create: function(context) {\n        // Extracts any HTML tags.\n        var regularTagPattern = /<(.+?)>/g;\n        // Extracts self closing HTML tags.\n        var selfClosingTagPattern = /<(.+?)\\/>/g;\n\n        var allowSimple = (context.options[0] && context.options[0].allowSimple) !== false;\n\n        function reportComplex(node) {\n            context.report(node, 'Inline template is too complex. Use an external template instead');\n        }\n\n        return {\n            Property: function(node) {\n                if (node.key.name !== 'template' || node.value.type !== 'Literal') {\n                    return;\n                }\n                if (!allowSimple) {\n                    context.report(node, 'Inline templates are not allowed. Use an external template instead');\n                }\n                if ((node.value.value && node.value.value.match(regularTagPattern) || []).length > 2) {\n                    return reportComplex(node);\n                }\n                if ((node.value.value && node.value.value.match(selfClosingTagPattern) || []).length > 1) {\n                    return reportComplex(node);\n                }\n                if (node.value && node.value.raw.indexOf('\\\\') !== -1) {\n                    reportComplex(node);\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/no-jquery-angularelement.js":"/**\n * disallow to wrap `angular.element` objects with `jQuery` or `$`\n *\n * You should not wrap angular.element object into jQuery(), because angular.element already return jQLite element\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        return {\n\n            MemberExpression: function(node) {\n                if (node.object.name === 'angular' && node.property.name === 'element') {\n                    if (node.parent !== undefined && node.parent.parent !== undefined &&\n                        node.parent.parent.type === 'CallExpression' &&\n                        node.parent.parent.callee.type === 'Identifier' &&\n                        (node.parent.parent.callee.name === 'jQuery' || node.parent.parent.callee.name === '$')) {\n                        context.report(node, 'angular.element returns already a jQLite element. No need to wrap with the jQuery object', {});\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/no-private-call.js":"/**\n * disallow use of internal angular properties prefixed with $$\n *\n * All scope's properties/methods starting with $$ are used internally by AngularJS.\n * You should not use them directly.\n * Exception can be allowed with this option: {allow:['$$watchers']}\n *\n * @version 0.1.0\n * @category possibleError\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: [\n            {\n                type: 'object',\n                properties: {\n                    allow: {\n                        type: 'array',\n                        items: {\n                            type: 'string'\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n    create: function(context) {\n        var options = context.options[0] || {};\n        var allowed = options.allow || [];\n\n        function check(node, name) {\n            if (name.slice(0, 2) === '$$' && allowed.indexOf(name) < 0) {\n                context.report(node, 'Using $$-prefixed Angular objects/methods are not recommended', {});\n            }\n        }\n        return {\n\n            Identifier: function(node) {\n                check(node, node.name);\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/no-run-logic.js":"/**\n * keep run functions clean and simple\n *\n * Initialization logic should be moved into a factory or service. This improves testability.\n *\n * @styleguideReference {johnpapa} `y171` Run Blocks\n * @version 0.15.0\n * @category bestPractice\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar angularRule = require('./utils/angular-rule');\n\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'object',\n            properties: {\n                allowParams: {\n                    type: 'boolean'\n                }\n            }\n        }]\n    },\n    create: angularRule(function(context) {\n        var options = context.options[0] || {};\n        var allowParams = options.allowParams !== false;\n\n        function report(node) {\n            context.report(node, 'The run function may only contain call expressions');\n        }\n\n        return {\n            'angular?run': function(callExpression, fn) {\n                if (!fn) {\n                    return;\n                }\n                fn.body.body.forEach(function(statement) {\n                    if (statement.type !== 'ExpressionStatement') {\n                        return report(statement);\n                    }\n                    var expression = statement.expression;\n                    if (expression.type !== 'CallExpression') {\n                        return report(statement);\n                    }\n                    if (expression.callee.type === 'MemberExpression' && expression.callee.object.type !== 'Identifier') {\n                        return report(statement);\n                    }\n                    if (!allowParams && expression.arguments.length) {\n                        return context.report(expression, 'Run function call expressions may not take any arguments');\n                    }\n                    expression.arguments.forEach(function(argument) {\n                        if (argument.type !== 'Literal' && argument.type !== 'Identifier') {\n                            context.report(argument, 'Run function call expressions may only take simple arguments');\n                        }\n                    });\n                });\n            }\n        };\n    })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/no-service-method.js":"/**\n * use `factory()` instead of `service()`\n *\n * You should prefer the factory() method instead of service()\n *\n * @styleguideReference {johnpapa} `y040` Services - Singletons\n * @version 0.1.0\n * @category conventions\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        return {\n\n            CallExpression: function(node) {\n                if (utils.isAngularComponent(node) && node.callee.property && node.callee.property.name === 'service') {\n                    context.report(node, 'You should prefer the factory() method instead of service()', {});\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/no-services.js":"/**\n * disallow DI of specified services\n *\n * Some services should be used only in a specific AngularJS service (Ajax-based service for example), in order to follow the separation of concerns paradigm.\n * The second parameter specifies the services.\n * The third parameter can be a list of angular objects (controller, factory, etc.).\n * Or second parameter can be an object, where keys are angular object names and value is a list of services (like {controller: ['$http'], factory: ['$q']})\n *\n * @linkDescription disallow DI of specified services for other angular components (`$http` for controllers, filters and directives)\n * @version 0.1.0\n * @category bestPractice\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nconst utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: ['array', 'object']\n        }, {\n            type: 'array'\n        }]\n    },\n    create: function(context) {\n        let angularObjectList = ['controller', 'filter', 'directive'];\n        let badServices = [];\n        let map;\n        let message = 'REST API calls should be implemented in a specific service';\n\n        function isArray(item) {\n            return Object.prototype.toString.call(item) === '[object Array]';\n        }\n\n        function isObject(item) {\n            return Object.prototype.toString.call(item) === '[object Object]';\n        }\n\n        if (context.options[0] === undefined) {\n            badServices = [/\\$http/, /\\$resource/, /Restangular/, /\\$q/, /\\$filter/];\n        }\n\n        if (isArray(context.options[0])) {\n            badServices = context.options[0];\n        }\n\n        if (isArray(context.options[1])) {\n            angularObjectList = context.options[1];\n        }\n\n        if (isObject(context.options[0])) {\n            map = context.options[0];\n\n            let result = [];\n            let prop;\n\n            for (prop in map) {\n                if (map.hasOwnProperty(prop)) {\n                    result.push(prop);\n                }\n            }\n\n            angularObjectList = result;\n        }\n\n        function isSetBedService(serviceName, angularObjectName) {\n            if (map) {\n                return map[angularObjectName].find(object => utils.convertPrefixToRegex(object).test(serviceName));\n            }\n            return badServices.find(object => utils.convertPrefixToRegex(object).test(serviceName));\n        }\n\n        return {\n\n            CallExpression: function(node) {\n                let callee = node.callee;\n\n                if (utils.isAngularComponent(node) && callee.type === 'MemberExpression' && angularObjectList.indexOf(callee.property.name) >= 0) {\n                    if (utils.isFunctionType(node.arguments[1])) {\n                        node.arguments[1].params.forEach(function(service) {\n                            if (service.type === 'Identifier' && isSetBedService(service.name, callee.property.name)) {\n                                context.report(node, message + ' (' + service.name + ' in ' + callee.property.name + ')', {});\n                            }\n                        });\n                    }\n\n                    if (utils.isArrayType(node.arguments[1])) {\n                        node.arguments[1].elements.forEach(function(service) {\n                            if (service.type === 'Literal' && isSetBedService(service.value, callee.property.name)) {\n                                context.report(node, message + ' (' + service.value + ' in ' + callee.property.name + ')', {});\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/on-destroy.js":"/**\n * Check for common misspelling $on('destroy', ...).\n *\n * It should be $on('$destroy', ...).\n * @version 0.1.0\n * @category misspelling\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        function report(node) {\n            context.report(node, 'You probably misspelled $on(\"$destroy\").');\n        }\n\n        /**\n         * Return true if the given node is a call expression calling a function\n         * named '$on'.\n         */\n        function isOn(node) {\n            var calledFunction = node.callee;\n            if (calledFunction.type !== 'MemberExpression') {\n                return false;\n            }\n\n            // can only easily tell what name was used if a simple\n            // identifiers were used to access it.\n            var accessedFunction = calledFunction.property;\n            if (accessedFunction.type !== 'Identifier') {\n                return false;\n            }\n\n            var functionName = accessedFunction.name;\n\n            return functionName === '$on';\n        }\n\n        /**\n         * Return true if the given node is a call expression that has a first\n         * argument of the string '$destroy'.\n         */\n        function isFirstArgDestroy(node) {\n            var args = node.arguments;\n\n            return (args.length >= 1 &&\n                args[0].type === 'Literal' &&\n                args[0].value === 'destroy');\n        }\n\n        return {\n            CallExpression: function(node) {\n                if (isOn(node) && isFirstArgDestroy(node)) {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/on-watch.js":"/**\n * require `$on` and `$watch` deregistration callbacks to be saved in a variable\n *\n * Watch and On methods on the scope object should be assigned to a variable, in order to be deleted in a $destroy event handler\n * @version 0.1.0\n * @category bestPractice\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        function report(node, method) {\n            context.report(node, 'The \"{{method}}\" call should be assigned to a variable, in order to be destroyed during the $destroy event', {\n                method: method\n            });\n        }\n\n        /**\n         * Return true if the given node is a call expression calling a function\n         * named '$on' or '$watch' on an object named '$scope', '$rootScope' or\n         * 'scope'.\n         */\n        function isScopeOnOrWatch(node, scopes) {\n            if (node.type !== 'CallExpression') {\n                return false;\n            }\n\n            var calledFunction = node.callee;\n            if (calledFunction.type !== 'MemberExpression') {\n                return false;\n            }\n\n            // can only easily tell what name was used if a simple\n            // identifiers were used to access it.\n            var parentObject = calledFunction.object;\n            var accessedFunction = calledFunction.property;\n\n            // cannot check name of the parent object if it is returned from a\n            // complex expression.\n            if (parentObject.type !== 'Identifier' ||\n                accessedFunction.type !== 'Identifier') {\n                return false;\n            }\n\n            var objectName = parentObject.name;\n            var functionName = accessedFunction.name;\n\n            return scopes.indexOf(objectName) >= 0 && (functionName === '$on' ||\n                functionName === '$watch');\n        }\n\n        /**\n         * Return true if the given node is a call expression that has a first\n         * argument of the string '$destroy'.\n         */\n        function isFirstArgDestroy(node) {\n            var args = node.arguments;\n\n            return (args.length >= 1 &&\n                args[0].type === 'Literal' &&\n                args[0].value === '$destroy');\n        }\n\n        return {\n\n            CallExpression: function(node) {\n                if (isScopeOnOrWatch(node, ['$rootScope']) && !isFirstArgDestroy(node)) {\n                    if (node.parent.type !== 'VariableDeclarator' &&\n                        node.parent.type !== 'AssignmentExpression' &&\n                        !(isScopeOnOrWatch(node.parent, ['$rootScope', '$scope', 'scope']) &&\n                            isFirstArgDestroy(node.parent))) {\n                        report(node, node.callee.property.name);\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/one-dependency-per-line.js":"/**\n * require all DI parameters to be located in their own line\n *\n * Injected dependencies should be written one per line.\n *\n * @version 0.14.0\n * @category conventions\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        var angularObjectList = ['animation', 'config', 'constant', 'controller', 'directive', 'factory', 'filter', 'provider', 'service', 'value', 'decorator'];\n\n        function checkArgumentPositionInFunction(node) {\n            if (!node.params || node.params.length < 2) {\n                return;\n            }\n\n            var linesFound = [];\n            node.params.forEach(reportMultipleItemsInOneLine.bind(null, node, linesFound));\n        }\n\n        function reportMultipleItemsInOneLine(node, linesFound, item) {\n            var currentLine = item.loc.start.line;\n            if (linesFound.indexOf(currentLine) !== -1) {\n                context.report({\n                    node: node,\n                    message: 'Do not use multiple dependencies in one line',\n                    loc: item.loc.start\n                });\n            }\n            linesFound.push(currentLine);\n        }\n\n        function checkArgumentPositionArrayExpression(angularComponentNode, arrayNode) {\n            var linesFound = [];\n\n            arrayNode.elements.forEach(function(element) {\n                if (element.type === 'Literal') {\n                    reportMultipleItemsInOneLine(arrayNode, linesFound, element);\n                }\n                if (element.type === 'FunctionExpression') {\n                    checkArgumentPositionInFunction(element);\n                }\n                if (element.type === 'Identifier') {\n                    var fn = getFunctionDeclaration(angularComponentNode, element.name);\n                    checkArgumentPositionInFunction(fn);\n                }\n            });\n        }\n\n        function findFunctionDeclarationByDeclaration(body, fName) {\n            return body.find(function(item) {\n                return item.type === 'FunctionDeclaration' && item.id.name === fName;\n            });\n        }\n\n        function findFunctionDeclarationByVariableDeclaration(body, fName) {\n            var fn;\n            body.forEach(function(item) {\n                if (fn) {\n                    return;\n                }\n                if (item.type === 'VariableDeclaration') {\n                    item.declarations.forEach(function(declaration) {\n                        if (declaration.type === 'VariableDeclarator' &&\n                            declaration.id &&\n                            declaration.id.name === fName &&\n                            declaration.init &&\n                            declaration.init.type === 'FunctionExpression'\n                        ) {\n                            fn = declaration.init;\n                        }\n                    });\n                }\n            });\n            return fn;\n        }\n\n        function getFunctionDeclaration(node, fName) {\n            if (node.type === 'BlockStatement' || node.type === 'Program') {\n                if (node.body) {\n                    var fn = findFunctionDeclarationByDeclaration(node.body, fName);\n                    if (fn) {\n                        return fn;\n                    }\n                    fn = findFunctionDeclarationByVariableDeclaration(node.body, fName);\n                    if (fn) {\n                        return fn;\n                    }\n                }\n            }\n            if (node.parent) {\n                return getFunctionDeclaration(node.parent, fName);\n            }\n        }\n\n        return {\n\n            CallExpression: function(node) {\n                var fn;\n                if (utils.isAngularComponent(node) &&\n                    node.callee.type === 'MemberExpression' &&\n                    node.arguments[1].type === 'FunctionExpression' &&\n                    angularObjectList.indexOf(node.callee.property.name) >= 0) {\n                    fn = node.arguments[1];\n                    return checkArgumentPositionInFunction(fn);\n                }\n                if (utils.isAngularComponent(node) &&\n                    node.callee.type === 'MemberExpression' &&\n                    node.arguments[1].type === 'Identifier' &&\n                    angularObjectList.indexOf(node.callee.property.name) >= 0) {\n                    var fName = node.arguments[1].name;\n                    fn = getFunctionDeclaration(node, fName);\n                    if (fn) {\n                        return checkArgumentPositionInFunction(fn);\n                    }\n                }\n                if (utils.isAngularComponent(node) &&\n                    node.callee.type === 'MemberExpression' &&\n                    node.arguments[1].type === 'ArrayExpression' &&\n                    angularObjectList.indexOf(node.callee.property.name) >= 0) {\n                    return checkArgumentPositionArrayExpression(node, node.arguments[1]);\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/prefer-component.js":"/*\n * Since AngularJS 1.5, we can use a new API when creating directives.\n * This new API should be use when creating directive without DOM manipulation.\n *\n * @version 0.16.0\n * @category bestPractice\n * @sinceAngularVersion 1.5\n */\n'use strict';\n\nvar angularRule = require('./utils/angular-rule');\nvar allowedProperties = ['compile', 'link', 'multiElement', 'priority', 'templateNamespace', 'terminal'];\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: angularRule(function(context) {\n        var potentialReplaceNodes = {};\n\n        function addPotentialLinkNode(variableName, node) {\n            var nodeList = potentialReplaceNodes[variableName] || [];\n\n            nodeList.push({\n                name: variableName,\n                node: node,\n                block: context.getScope().block.body\n            });\n\n            potentialReplaceNodes[variableName] = nodeList;\n        }\n\n        return {\n            'angular?directive': function(callExpressionNode, fnNode) {\n                if (!fnNode || !fnNode.body) {\n                    return;\n                }\n                fnNode.body.body.forEach(function(statement) {\n                    if (statement.type === 'ReturnStatement' && !potentialReplaceNodes[statement.argument.name || '']) {\n                        context.report(statement, 'Directive should be implemented with the component method.');\n                    }\n                });\n            },\n            AssignmentExpression: function(node) {\n                // Only check for literal member property assignments.\n                if (node.left.type !== 'MemberExpression') {\n                    return;\n                }\n\n                if (allowedProperties.indexOf(node.left.property.name) < 0) {\n                    return;\n                }\n\n                addPotentialLinkNode(node.left.object.name, node);\n            },\n            Property: function(node) {\n                if (node.key.name === 'restrict') {\n                    if (node.value.raw && node.value.raw.indexOf('C') < 0 && node.value.raw.indexOf('A') < 0) {\n                        return;\n                    }\n                } else if (allowedProperties.indexOf(node.key.name) < 0) {\n                    return;\n                }\n\n                // assumption: Property always belongs to a ObjectExpression\n                var objectExpressionParent = node.parent.parent;\n\n                // add to potential link nodes if the object is defined in a variable\n                if (objectExpressionParent.type === 'VariableDeclarator') {\n                    addPotentialLinkNode(objectExpressionParent.id.name, node);\n                }\n\n                // report directly if object is part of a return statement and inside a directive body\n                if (objectExpressionParent.type === 'ReturnStatement') {\n                    addPotentialLinkNode('', node);\n                }\n            }\n        };\n    })\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/provider-name.js":"/**\n * require and specify a prefix for all provider names\n *\n * All your providers should have a name starting with the parameter you can define in your config object.\n * The second parameter can be a Regexp wrapped in quotes.\n * You can not prefix your providers by \"$\" (reserved keyword for AngularJS services) (\"provider-name\":  [2, \"ng\"])\n **\n * @styleguideReference {johnpapa} `y125` Naming - Factory and Service Names\n * @version 0.1.0\n * @category naming\n */\n'use strict';\n\n\nvar utils = require('./utils/utils');\n\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: ['string', 'object']\n        }, {\n            type: 'object'\n        }]\n    },\n    create: function(context) {\n        return {\n\n            CallExpression: function(node) {\n                var prefix = context.options[0];\n                var convertedPrefix; // convert string from JSON .eslintrc to regex\n                var isProvider;\n\n                if (prefix === undefined) {\n                    return;\n                }\n\n                convertedPrefix = utils.convertPrefixToRegex(prefix);\n                isProvider = utils.isAngularProviderDeclaration(node);\n\n                if (isProvider) {\n                    var name = node.arguments[0].value;\n\n                    if (name !== undefined && name.indexOf('$') === 0) {\n                        context.report(node, 'The {{provider}} provider should not start with \"$\". This is reserved for AngularJS services', {\n                            provider: name\n                        });\n                    } else if (name !== undefined && !convertedPrefix.test(name)) {\n                        if (typeof prefix === 'string' && !utils.isStringRegexp(prefix)) {\n                            context.report(node, 'The {{provider}} provider should be prefixed by {{prefix}}', {\n                                provider: name,\n                                prefix: prefix\n                            });\n                        } else {\n                            context.report(node, 'The {{provider}} provider should follow this pattern: {{prefix}}', {\n                                provider: name,\n                                prefix: prefix.toString()\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/rest-service.js":"/**\n * disallow different rest service and specify one of '$http', '$resource', 'Restangular'\n *\n * Check the service used to send request to your REST API.\n * This rule can have one parameter, with one of the following values: $http, $resource or Restangular ('rest-service': [0, '$http']).\n *\n * @version 0.5.0\n * @category conventions\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: 'string'\n        }]\n    },\n    create: function(context) {\n        var angularObjectList = ['controller', 'filter', 'directive', 'service', 'factory', 'provider'];\n        var services = ['$http', '$resource', 'Restangular'];\n        var message = 'You should use the same service ({{method}}) for REST API calls';\n\n\n        return {\n\n            CallExpression: function(node) {\n                function checkElement(element) {\n                    if (element.type === 'Identifier' && services.indexOf(element.name) >= 0 && context.options[0] !== element.name) {\n                        context.report(node, message, {\n                            method: context.options[0]\n                        });\n                    } else if (element.type === 'Literal' && services.indexOf(element.value) >= 0 && context.options[0] !== element.value) {\n                        context.report(node, message, {\n                            method: context.options[0]\n                        });\n                    }\n                }\n\n                function checkAllElements(elements) {\n                    elements.forEach(checkElement);\n                }\n\n                var callee = node.callee;\n\n                if (utils.isAngularComponent(node) && callee.type === 'MemberExpression' && angularObjectList.indexOf(callee.property.name) >= 0) {\n                    if (utils.isFunctionType(node.arguments[1])) {\n                        checkAllElements(node.arguments[1].params);\n                    }\n\n                    if (utils.isArrayType(node.arguments[1])) {\n                        checkAllElements(node.arguments[1].elements);\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/service-name.js":"/**\n * require and specify a prefix for all service names\n *\n * All your services should have a name starting with the parameter you can define in your config object.\n * The second parameter can be a Regexp wrapped in quotes.\n * You can not prefix your services by \"$\" (reserved keyword for AngularJS services) (\"service-name\":  [2, \"ng\"])\n **\n * @styleguideReference {johnpapa} `y125` Naming - Factory and Service Names\n * @version 0.1.0\n * @category naming\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\n\nvar utils = require('./utils/utils');\n\n/**\n * @param {Array.<*>} options\n * @returns {?string}\n */\nfunction getPrefixFromOptions(options) {\n    return options.find(function(option) {\n        return ['String', 'RegExp', 'Null', 'Undefined'].indexOf(utils.getToStringTagType(option)) !== -1;\n    });\n}\n\n/**\n * @param {Array.<*>} options\n * @returns {Object}\n */\nfunction getConfig(options) {\n    var config = options.find(function(option) {\n        return utils.getToStringTagType(option) === 'Object';\n    });\n\n    config = config || {};\n    if (typeof config.oldBehavior !== 'boolean') {\n        config = Object.assign({\n            oldBehavior: true\n        });\n    }\n\n    return config;\n}\n\n/**\n * Used only by `ForDeprecatedBehavior()` for making sure it was run only one time\n * @type {boolean}\n */\nvar didWarnForDeprecatedBehavior = false;\n\n/**\n * Warn if API is deprecated\n * @param {Array.<*>} options\n */\nfunction warnForDeprecatedBehavior(options) {\n    if (didWarnForDeprecatedBehavior) {\n        return;\n    }\n    didWarnForDeprecatedBehavior = true;\n\n    var config = getConfig(options);\n\n    /* istanbul ignore if  */\n    if (config.oldBehavior) {\n        // eslint-disable-next-line\n        console.warn('The rule `angular/service-name` will be split up to different rules in the next version. Please read the docs for more information');\n    }\n}\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: ['string', 'object']\n        }, {\n            type: 'object'\n        }]\n    },\n    create: function(context) {\n        warnForDeprecatedBehavior(context.options);\n\n        return {\n\n            CallExpression: function(node) {\n                var config = getConfig(context.options);\n                var prefix = getPrefixFromOptions(context.options);\n                var convertedPrefix; // convert string from JSON .eslintrc to regex\n                var isService;\n\n                if (prefix === undefined) {\n                    return;\n                }\n\n                convertedPrefix = utils.convertPrefixToRegex(prefix);\n\n                if (config.oldBehavior) {\n                    isService = utils.isAngularServiceDeclarationDeprecated(node);\n                } else {\n                    isService = utils.isAngularServiceDeclaration(node);\n                }\n\n                if (isService) {\n                    var name = node.arguments[0].value;\n\n                    if (name !== undefined && name.indexOf('$') === 0) {\n                        context.report(node, 'The {{service}} service should not start with \"$\". This is reserved for AngularJS services', {\n                            service: name\n                        });\n                    } else if (name !== undefined && !convertedPrefix.test(name)) {\n                        if (typeof prefix === 'string' && !utils.isStringRegexp(prefix)) {\n                            context.report(node, 'The {{service}} service should be prefixed by {{prefix}}', {\n                                service: name,\n                                prefix: prefix\n                            });\n                        } else {\n                            context.report(node, 'The {{service}} service should follow this pattern: {{prefix}}', {\n                                service: name,\n                                prefix: prefix.toString()\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/timeout-service.js":"/**\n * use `$timeout` instead of `setTimeout`\n *\n * Instead of the default setTimeout function, you should use the AngularJS wrapper service $timeout\n **\n * @styleguideReference {johnpapa} `y181` Angular $ Wrapper Services - $timeout and $interval\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        var message = 'You should use the $timeout service instead of the default window.setTimeout method';\n\n        return {\n\n            MemberExpression: function(node) {\n                if (node.property.name !== 'setTimeout') {\n                    return;\n                }\n\n                if (node.object.type === 'Identifier') {\n                    if ((node.object.name === 'window' || node.object.name === '$window')) {\n                        context.report(node, message, {});\n                    }\n\n                    return;\n                }\n\n                // Detect expression this.$window.setTimeout which is what we would see in ES6 code when using classes\n                var parentNode = node.object;\n\n                if (parentNode.object.type === 'ThisExpression' && parentNode.property.name === '$window') {\n                    context.report(node, message, {});\n                }\n            },\n\n            CallExpression: function(node) {\n                if (node.callee.name === 'setTimeout') {\n                    context.report(node, message, {});\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/typecheck-array.js":"/**\n * use `angular.isArray` instead of `typeof` comparisons\n *\n * You should use the angular.isArray method instead of the default JavaScript implementation (typeof [] === \"[object Array]\").\n *\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        function recordError(node, origin) {\n            if (node.type === 'Literal' && node.value === '[object Array]') {\n                context.report(origin, 'You should use the angular.isArray method', {});\n            }\n        }\n\n        return {\n            MemberExpression: function(node) {\n                if (node.object.name === 'Array' && node.property.name === 'isArray') {\n                    context.report(node, 'You should use the angular.isArray method', {});\n                }\n            },\n            BinaryExpression: function(node) {\n                if (node.operator === '===' || node.operator === '!==') {\n                    if (utils.isTypeOfStatement(node.left) || utils.isToStringStatement(node.left)) {\n                        recordError(node.right, node);\n                    } else if (utils.isTypeOfStatement(node.right) || utils.isToStringStatement(node.right)) {\n                        recordError(node.left, node);\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/typecheck-date.js":"/**\n * use `angular.isDate` instead of `typeof` comparisons\n *\n * You should use the angular.isDate method instead of the default JavaScript implementation (typeof new Date() === \"[object Date]\").\n *\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        function recordError(node, origin) {\n            if (node.type === 'Literal' && node.value === '[object Date]') {\n                context.report(origin, 'You should use the angular.isDate method', {});\n            }\n        }\n\n        return {\n\n            BinaryExpression: function(node) {\n                if (node.operator === '===' || node.operator === '!==') {\n                    if (utils.isTypeOfStatement(node.left) || utils.isToStringStatement(node.left)) {\n                        recordError(node.right, node);\n                    } else if (utils.isTypeOfStatement(node.right) || utils.isToStringStatement(node.right)) {\n                        recordError(node.left, node);\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/typecheck-function.js":"/**\n * use `angular.isFunction` instead of `typeof` comparisons\n *\n * You should use the angular.isFunction method instead of the default JavaScript implementation (typeof function(){} ===\"[object Function]\").\n *\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        function recordError(node, origin) {\n            if (node.type === 'Literal' && (node.value === 'function' || node.value === '[object Function]')) {\n                context.report(origin, 'You should use the angular.isFunction method', {});\n            }\n        }\n\n        return {\n\n            BinaryExpression: function(node) {\n                if (node.operator === '===' || node.operator === '!==') {\n                    if (utils.isTypeOfStatement(node.left) || utils.isToStringStatement(node.left)) {\n                        recordError(node.right, node);\n                    } else if (utils.isTypeOfStatement(node.right) || utils.isToStringStatement(node.right)) {\n                        recordError(node.left, node);\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/typecheck-number.js":"/**\n * use `angular.isNumber` instead of `typeof` comparisons\n *\n * You should use the angular.isNumber method instead of the default JavaScript implementation (typeof 3 === \"[object Number]\").\n *\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        function recordError(node, origin) {\n            if (node.type === 'Literal' && (node.value === 'number' || node.value === '[object Number]')) {\n                context.report(origin, 'You should use the angular.isNumber method', {});\n            }\n        }\n\n\n        return {\n\n            BinaryExpression: function(node) {\n                if (node.operator === '===' || node.operator === '!==') {\n                    if (utils.isTypeOfStatement(node.left) || utils.isToStringStatement(node.left)) {\n                        recordError(node.right, node);\n                    } else if (utils.isTypeOfStatement(node.right) || utils.isToStringStatement(node.right)) {\n                        recordError(node.left, node);\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/typecheck-object.js":"/**\n * use `angular.isObject` instead of `typeof` comparisons\n *\n * You should use the angular.isObject method instead of the default JavaScript implementation (typeof {} === \"[object Object]\").\n *\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        function recordError(node, origin) {\n            if (node.type === 'Literal' && (node.value === 'object' || node.value === '[object Object]')) {\n                context.report(origin, 'You should use the angular.isObject method', {});\n            }\n        }\n\n        return {\n            BinaryExpression: function(node) {\n                if (node.operator === '===' || node.operator === '!==') {\n                    if (utils.isTypeOfStatement(node.left) || utils.isToStringStatement(node.left)) {\n                        recordError(node.right, node);\n                    } else if (utils.isTypeOfStatement(node.right) || utils.isToStringStatement(node.right)) {\n                        recordError(node.left, node);\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/typecheck-string.js":"/**\n * use `angular.isString` instead of `typeof` comparisons\n *\n * You should use the angular.isString method instead of the default JavaScript implementation (typeof \"\" === \"[object String]\").\n *\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nvar utils = require('./utils/utils');\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        function recordError(node, origin) {\n            if (node.type === 'Literal' && (node.value === 'string' || node.value === '[object String]')) {\n                context.report(origin, 'You should use the angular.isString method', {});\n            }\n        }\n\n        return {\n\n            BinaryExpression: function(node) {\n                if (node.operator === '===' || node.operator === '!==') {\n                    if (utils.isTypeOfStatement(node.left) || utils.isToStringStatement(node.left)) {\n                        recordError(node.right, node);\n                    } else if (utils.isTypeOfStatement(node.right) || utils.isToStringStatement(node.right)) {\n                        recordError(node.left, node);\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/value-name.js":"/**\n * require and specify a prefix for all value names\n *\n * All your values should have a name starting with the parameter you can define in your config object.\n * The second parameter can be a Regexp wrapped in quotes.\n * You can not prefix your values by \"$\" (reserved keyword for AngularJS services) (\"value-name\":  [2, \"ng\"])\n **\n * @styleguideReference {johnpapa} `y125` Naming - Factory and Service Names\n * @version 0.1.0\n * @category naming\n */\n'use strict';\n\n\nvar utils = require('./utils/utils');\n\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            type: ['string', 'object']\n        }]\n    },\n    create: function(context) {\n        return {\n\n            CallExpression: function(node) {\n                var prefix = context.options[0];\n                var convertedPrefix; // convert string from JSON .eslintrc to regex\n                var isValue;\n\n                if (prefix === undefined) {\n                    return;\n                }\n\n                convertedPrefix = utils.convertPrefixToRegex(prefix);\n                isValue = utils.isAngularValueDeclaration(node);\n\n                if (isValue) {\n                    var name = node.arguments[0].value;\n\n                    if (name !== undefined && name.indexOf('$') === 0) {\n                        context.report(node, 'The {{value}} value should not start with \"$\". This is reserved for AngularJS services', {\n                            value: name\n                        });\n                    } else if (name !== undefined && !convertedPrefix.test(name)) {\n                        if (typeof prefix === 'string' && !utils.isStringRegexp(prefix)) {\n                            context.report(node, 'The {{value}} value should be prefixed by {{prefix}}', {\n                                value: name,\n                                prefix: prefix\n                            });\n                        } else {\n                            context.report(node, 'The {{value}} value should follow this pattern: {{prefix}}', {\n                                value: name,\n                                prefix: prefix.toString()\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/watchers-execution.js":"/**\n * require and specify consistent use `$scope.digest()` or `$scope.apply()`\n *\n * For the execution of the watchers, the $digest method will start from the scope in which we call the method.\n * This will cause an performance improvement comparing to the $apply method, who start from the $rootScope\n *\n * @version 0.4.0\n * @category conventions\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: [{\n            enum: ['$apply', '$digest']\n        }]\n    },\n    create: function(context) {\n        var method = context.options[0] || '$digest';\n        var methods = ['$apply', '$digest'];\n        return {\n\n            MemberExpression: function(node) {\n                var forbiddenMethod = methods.filter(function(m) {\n                    return m !== method;\n                });\n                if (forbiddenMethod.length > 0 && node.property.type === 'Identifier' && forbiddenMethod.indexOf(node.property.name) >= 0) {\n                    context.report(node, 'Instead of using the {{forbidden}}() method, you should prefer {{method}}()', {\n                        forbidden: node.property.name,\n                        method: method\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/rules/window-service.js":"/**\n * use `$window` instead of `window`\n *\n * Instead of the default window object, you should prefer the AngularJS wrapper service $window.\n *\n * @styleguideReference {johnpapa} `y180` Angular $ Wrapper Services - $document and $window\n * @version 0.1.0\n * @category angularWrapper\n * @sinceAngularVersion 1.x\n */\n'use strict';\n\nmodule.exports = {\n    meta: {\n        schema: []\n    },\n    create: function(context) {\n        var restrict = ['document', 'setInterval', 'setTimeout'];\n        return {\n\n            MemberExpression: function(node) {\n                if (node.object.name === 'window' && restrict.indexOf(node.property.name) < 0) {\n                    context.report(node, 'You should use the $window service instead of the default window object', {});\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-angular/eslint-plugin-angular/environments.js":"'use strict';\n\nmodule.exports = {\n    angular: {\n        globals: {\n            angular: true\n        }\n    },\n    // https://docs.angularjs.org/api/ngMock\n    mocks: {\n        globals: {\n            angular: true,\n            inject: true,\n            module: true\n        }\n    },\n    // http://www.protractortest.org/#/api\n    protractor: {\n        globals: {\n            element: true,\n            $: true,\n            $$: true,\n            browser: true,\n            by: true,\n            protractor: true\n        }\n    }\n};\n"}